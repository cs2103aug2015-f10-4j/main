# A0131729E
###### command\AddCommand.java
``` java
 */
public class AddCommand extends Command {

	/** Messaging */
	private static final String MESSAGE_TASK_ADDED = "Task added";
	private static final String MESSAGE_TASK_CLASH = ". Another task exists on the same date.";
	private static final String MESSAGE_TASK_ERROR = "Unable to add task";

	/** Command parameters **/
	private Item task;

	/**
	 * Constructor for AddCommand objects. Checks if arguments are valid and
	 * stores the correct arguments properly. Throws the appropriate exception
	 * if arguments are invalid. Contains methods to add a task to storage.
	 * 
	 * @param args
	 * @param endTime
	 * @param dueDate
	 * @throws Exception
	 */
	public AddCommand(String title, CustomDate dueDate, int endTime)
			throws Exception {
		task = new Item();
		task.setType("task");
		task.setTitle(title);
		task.setStartDate(null);
		task.setStartTime(-1);
		task.setEndDate(dueDate);
		task.setEndTime(endTime);
	}

	/**
	 * Checks if the task to be added clashes with another task and adds to the
	 * return message to inform the user
	 */
	private void checkTaskClash() {
		if (isClashing()) {
			returnMsg += MESSAGE_TASK_CLASH;
		}
	}

	/**
	 * Checks if the current task to be added clashes with another task
	 * 
	 * @return
	 */
	private boolean isClashing() {
		ArrayList<Item> tasks = getTasks();
		for (Item t : tasks) {
			if (isSameEndDate(t)) {
				return true;
			}
		}
		return false;
	}

	/**
	 * get task list from storage
	 * 
	 * @return
	 */
	private ArrayList<Item> getTasks() {
		ArrayList<Item> tasks = Magical.getStorage().getList(
				Storage.TASKS_INDEX);
		return tasks;
	}

	/**
	 * Checks if a given task has end date and is the same as the the created
	 * task
	 * 
	 * @param t
	 * @return
	 */
	private boolean isSameEndDate(Item t) {
		return t.getEndDate() != null
				&& t.getEndDate().equals(task.getEndDate());
	}

	/**
	 * Stores the created Item Object as task
	 * 
	 * @throws IOException
	 */
	private void storeTask() throws IOException {
		Magical.getStorage().create(Storage.TASKS_INDEX, task);
		Magical.addDisplayList(Storage.TASKS_INDEX, task);
	}

	@Override
	public boolean isUndoable() {
		return true;
	}

	/**
	 * Adds a new task to the storage using the parameters stored
	 * 
	 * @return message to show user
	 */
	public String execute() {
		try {
			returnMsg = MESSAGE_TASK_ADDED;
			checkTaskClash();
			storeTask();
			return returnMsg;
		} catch (IOException e) {
			return MESSAGE_TASK_ERROR;
		} finally {
			updateView();
			Magical.setCurrentTab("tasks");
		}
	}
}
```
###### command\Command.java
``` java
 */
public abstract class Command {

	/** Messaging **/
	protected String returnMsg = "";

	/** For checking **/
	protected static final CustomDate today = new CustomDate(Chronic
			.parse("today 00:00").getEndCalendar().getTime());

	/**
	 * Constructor for Command objects. Stores the arguments passed in when the
	 * constructor is called.
	 * 
	 * @param args
	 */
	public Command() {

	}

	/**
	 * Updates the new view in the GUI
	 */
	void updateView() {
		ArrayList<Item> updatedTaskList = Magical
				.getDisplayList(Storage.TASKS_INDEX);
		ArrayList<Item> updatedTaskDoneList = Magical
				.getDisplayList(Storage.TASKS_DONE_INDEX);
		ArrayList<Item> updatedEventList = Magical
				.getDisplayList(Storage.EVENTS_INDEX);
		ArrayList<Item> updatedEventDoneList = Magical
				.getDisplayList(Storage.EVENTS_DONE_INDEX);
		Magical.setDisplayList(Storage.TASKS_INDEX, updatedTaskList);
		Magical.setDisplayList(Storage.TASKS_DONE_INDEX, updatedTaskDoneList);
		Magical.setDisplayList(Storage.EVENTS_INDEX, updatedEventList);
		Magical.setDisplayList(Storage.EVENTS_DONE_INDEX, updatedEventDoneList);
	}

	/**
	 * Updates the new view in the GUI
	 */
	void updateViewStorage() {
		ArrayList<Item> updatedTaskList = Magical.getStorage().getList(
				Storage.TASKS_INDEX);
		ArrayList<Item> updatedTaskDoneList = Magical.getStorage().getList(
				Storage.TASKS_DONE_INDEX);
		ArrayList<Item> updatedEventList = Magical.getStorage().getList(
				Storage.EVENTS_INDEX);
		ArrayList<Item> updatedEventDoneList = Magical.getStorage().getList(
				Storage.EVENTS_DONE_INDEX);
		Magical.setDisplayList(Storage.TASKS_INDEX, updatedTaskList);
		Magical.setDisplayList(Storage.TASKS_DONE_INDEX, updatedTaskDoneList);
		Magical.setDisplayList(Storage.EVENTS_INDEX, updatedEventList);
		Magical.setDisplayList(Storage.EVENTS_DONE_INDEX, updatedEventDoneList);
	}

	/**
	 * Updates the new view in the GUI
	 */
	void updateView(ArrayList<Item> newTaskList,
			ArrayList<Item> newTaskDoneList, ArrayList<Item> newEventList,
			ArrayList<Item> newEventDoneList) {

		Magical.setDisplayList(Storage.TASKS_INDEX, newTaskList);
		Magical.setDisplayList(Storage.TASKS_DONE_INDEX, newTaskDoneList);
		Magical.setDisplayList(Storage.EVENTS_INDEX, newEventList);
		Magical.setDisplayList(Storage.EVENTS_DONE_INDEX, newEventDoneList);
	}

	/**
	 * Indicates if the command can be undone or not
	 * 
	 * @return boolean true/false
	 */
	public abstract boolean isUndoable();

	/**
	 * Implements functionality for each Command subclass.
	 * 
	 * @return String success/failure
	 * @throws Exception
	 */
	public abstract String execute() throws Exception;
}
```
###### command\DateCommand.java
``` java
 */
public class DateCommand extends Command {

	private static final String MESSAGE_DATE_SUCCESS = "Date command successful";

	/** Command parameters **/
	private CustomDate dateStart;
	private CustomDate dateEnd;

	/**
	 * Constructor for DateCommand objects. Checks if arguments are valid and
	 * stores the correct arguments properly. Throws the appropriate exception
	 * if arguments are invalid. Contains methods to display the date within the
	 * time range.
	 * 
	 * @param args
	 * @throws Exception
	 */
	public DateCommand(CustomDate dateStart, CustomDate dateEnd) {
		this.dateStart = dateStart;
		this.dateEnd = dateEnd;
	}

	/**
	 * Filter items according to date in the given list and return it
	 * 
	 * @param itemList
	 * @return filtered items to show user
	 */
	private ArrayList<Item> filterItems(ArrayList<Item> itemList) {
		ArrayList<Item> filteredItemList = new ArrayList<Item>();
		for (Item t : itemList) {
			if (t.getEndDate() != null
					&& t.getEndDate().compareTo(dateStart) >= 0
					&& t.getEndDate().compareTo(dateEnd) <= 0) {
				filteredItemList.add(t);
			}
		}
		return filteredItemList;
	}

	@Override
	public boolean isUndoable() {
		return false;
	}

	/**
	 * This method executes the date command, which filters through all the
	 * tasks and events and lists only those that fall within the specified date
	 * range.
	 * 
	 * @param None
	 *            .
	 * @return message to show user
	 */
	@Override
	public String execute() {
		ArrayList<Item> taskList = Magical.getStorage().getList(
				Storage.TASKS_INDEX);
		ArrayList<Item> taskDoneList = Magical.getStorage().getList(
				Storage.TASKS_DONE_INDEX);
		ArrayList<Item> eventList = Magical.getStorage().getList(
				Storage.EVENTS_INDEX);
		ArrayList<Item> eventDoneList = Magical.getStorage().getList(
				Storage.EVENTS_DONE_INDEX);

		ArrayList<Item> filteredTaskList = filterItems(taskList);
		ArrayList<Item> filteredTaskDoneList = filterItems(taskDoneList);
		ArrayList<Item> filteredEventList = filterItems(eventList);
		ArrayList<Item> filteredEventDoneList = filterItems(eventDoneList);

		updateView(filteredTaskList, filteredTaskDoneList, filteredEventList,
				filteredEventDoneList);

		return MESSAGE_DATE_SUCCESS;
	}
}
```
###### command\DelCommand.java
``` java
 */
public class DelCommand extends Command {

	private static final String MESSAGE_ITEM_DELETED = "%s deleted";
	private static final String MESSAGE_ITEM_ERROR_DELETE = "Unable to delete";

	/** Command Parameters **/
	private Item item;
	private String itemID;

	/**
	 * Constructor for DelCommand objects. Checks if arguments are valid and
	 * stores the correct arguments properly. Throws the appropriate exception
	 * if arguments are invalid. Contains methods to remove to item.
	 * 
	 * @param args
	 * @param item
	 * @throws Exception
	 */
	public DelCommand(String itemID, Item item) throws Exception {
		this.itemID = itemID;
		this.item = item;
	}

	/**
	 * Removes the item from storage
	 * 
	 * @throws IOException
	 */
	void removeItem() throws IOException {
		int listIndex = Storage.getListIndex(itemID);
		Magical.getStorage().delete(listIndex, item);
		Magical.deleteDisplayList(listIndex, item);
	}

	@Override
	public boolean isUndoable() {
		return true;
	}

	/**
	 * This method executes the delete command, which deletes the specified task
	 * or event from the database.
	 * 
	 * @return message to show user
	 * @throws Exception
	 */
	@Override
	public String execute() throws Exception {
		try {
			removeItem();
			return String.format(MESSAGE_ITEM_DELETED, itemID);
		} catch (IOException e) {
			throw new Exception(MESSAGE_ITEM_ERROR_DELETE);
		} finally {
			updateView();
		}
	}
}
```
###### command\DoneCommand.java
``` java
 */
public class DoneCommand extends Command {

	private static final String MESSAGE_DONE_ERROR = "Unable to archive %s";
	private static final String MESSAGE_DONE_SUCCESS = "%s archived";

	/** Command Parameters **/
	private Item item;
	private String itemID;

	/**
	 * Constructor for DoneCommand objects. Checks if arguments are valid and
	 * stores the correct arguments properly. Throws the appropriate exception
	 * if arguments are invalid. Contains methods to move item to done list.
	 * 
	 * @param args
	 * @param item
	 * @throws Exception
	 */
	public DoneCommand(String itemID, Item item) throws Exception {
		this.itemID = itemID;
		this.item = item;
	}

	/**
	 * Removes item from list and adds to complement(done) list
	 * 
	 * @throws IOException
	 */
	void doneItem() throws IOException {
		int listIndex = Storage.getListIndex(itemID);
		int complementListIndex = Storage.getComplementListIndex(listIndex);
		Magical.getStorage().delete(listIndex, item);
		Magical.getStorage().create(complementListIndex, item);
		Magical.deleteDisplayList(listIndex, item);
		Magical.addDisplayList(complementListIndex, item);
	}

	@Override
	public boolean isUndoable() {
		return true;
	}

	/**
	 * This method executes the done command. Which either moves a task or event
	 * to its corresponding done task or done event pile. .
	 * 
	 * @return message to show user
	 * @throws Exception
	 */
	@Override
	public String execute() throws Exception {
		try {
			doneItem();
		} catch (IOException e) {
			throw new Exception(String.format(MESSAGE_DONE_ERROR, itemID));
		} finally {
			updateView();
		}

		return String.format(MESSAGE_DONE_SUCCESS, itemID);
	}
}
```
###### command\EditCommand.java
``` java
 */
public class EditCommand extends Command {

	private static final String MESSAGE_ITEM_ERROR = "Unable to edit item %s";
	private static final String MESSAGE_ITEM_EDITED = "Item edited.";

	/** For checking **/
	private static final String FIELD_TIME_END = "end time";
	private static final String FIELD_TIME_START = "start time";
	private static final String FIELD_TIME = "time";
	private static final String FIELD_DATE_START = "start date";
	private static final String FIELD_DATE_END = "end date";
	private static final String FIELD_DATE = "date";
	private static final String FIELD_TITLE = "title";

	/** Command parameters **/
	private String field;
	private String itemID;
	private Item item;
	private Item prevItem;
	private boolean toFloat;
	private boolean isTask;
	private Object editObject;

	/**
	 * Constructor for EditCommand objects. Checks if arguments are valid and
	 * stores the correct arguments properly. Throws the appropriate exception
	 * if arguments are invalid. Contains methods to update the item in storage.
	 * 
	 * @param args
	 * @param editObject2
	 * @param item2
	 * @param itemID2
	 * @throws Exception
	 */
	public EditCommand(String field, Object editObject, String itemID,
			Item item, boolean isTask) throws Exception {
		this.field = field;
		this.editObject = editObject;
		this.itemID = itemID;
		this.item = item;
		this.isTask = isTask;
	}

	/**
	 * Checks whether the specified date range is valid for an event. If user
	 * tries to make start date after end date, he should be prompted with an
	 * error.
	 * 
	 * @throws IllegalArgumentException
	 */
	private void checkTimeValidity() throws IllegalStateException {
		if (!isTask && item.getEndDate().compareTo(item.getStartDate()) < 0) {
			if (field.toLowerCase().equals(FIELD_TIME_START)
					|| field.toLowerCase().equals(FIELD_DATE_START)) {
				throw new IllegalStateException(
						"Start Date should be before End Date");
			}
			throw new IllegalStateException(
					"End Date should be after Start Date");
		}
	}

	/**
	 * Make 2 copies of the item to be stored in prevItem and item
	 */
	void duplicateItem() {
		prevItem = item;
		item = prevItem.copy();
	}

	/**
	 * Sets the end time of an item to be 2359, the default time, if item is
	 * floating
	 */
	void unfloatItemForDate() {
		if (item.getEndTime() == -1) {
			item.setEndTime(2359);
		}
	}

	/**
	 * Gives a CustomDate object if the item is floating or a CustomDate object
	 * with the end date of the item
	 * 
	 * @return
	 */
	CustomDate unfloatItemForTime() {
		CustomDate date;
		if (item.getEndDate() == null) {
			date = today;
		} else {
			date = item.getEndDate();
		}
		return date;
	}

	/**
	 * Updates the original item with the new modified item
	 * 
	 * @throws IOException
	 */
	void updateItem() throws IOException {
		int listIndex = Storage.getListIndex(itemID);
		Magical.getStorage().update(listIndex, prevItem, item);
		Magical.updateDisplayList(listIndex, prevItem, item);
	}

	/**
	 * Set item with float parameters
	 */
	void floatItem() {
		item.setEndDate(null);
		item.setEndTime(-1);
	}

	@Override
	public boolean isUndoable() {
		return true;
	}

	/**
	 * Clones the current item and changes the value in the field specified.
	 * Updates storage with the new item.
	 * 
	 * @return message to show user
	 * @throws Exception
	 */
	@Override
	public String execute() throws Exception {
		duplicateItem();

		switch (field.toLowerCase()) {
		case FIELD_TITLE:
			item.setTitle((String) editObject);
			break;
		case FIELD_DATE_START:
			if (toFloat) {
				floatItem();
			} else {
				unfloatItemForDate();
				CustomDate date = (CustomDate) editObject;
				date.setTime(item.getEndTime());
				assertNotNull(date);
				item.setStartDate(date);
			}
			break;
		case FIELD_DATE_END:
			if (toFloat) {
				floatItem();
			} else {
				unfloatItemForDate();
				CustomDate date = (CustomDate) editObject;
				date.setTime(item.getEndTime());
				assertNotNull(date);
				item.setEndDate(date);
			}
			break;
		case FIELD_DATE:
			if (toFloat) {
				floatItem();
			} else {
				unfloatItemForDate();
				CustomDate date = (CustomDate) editObject;
				date.setTime(item.getEndTime());
				assertNotNull(date);
				item.setEndDate(date);
			}
			break;
		case FIELD_TIME_START:
			item.setStartTime((int) editObject);
			CustomDate date = unfloatItemForTime();
			assertNotNull(date);
			date.setTime(item.getStartTime());
			item.setStartDate(date);
			break;
		case FIELD_TIME_END:
			item.setEndTime((int) editObject);
			date = unfloatItemForTime();
			assertNotNull(date);
			date.setTime(item.getEndTime());
			item.setEndDate(date);
			break;
		case FIELD_TIME:
			item.setEndTime((int) editObject);
			date = unfloatItemForTime();
			assertNotNull(date);
			date.setTime(item.getEndTime());
			item.setEndDate(date);
			break;
		default:
			return MESSAGE_ITEM_ERROR;
		}

		try {
			checkTimeValidity();
			updateItem();
		} catch (IOException e) {
			throw new Exception(String.format(MESSAGE_ITEM_ERROR, itemID));
		} finally {
			updateView();
			if (isTask) {
				Magical.setCurrentTab("tasks");
			} else {
				Magical.setCurrentTab("events");
			}
		}

		return MESSAGE_ITEM_EDITED;
	}
}
```
###### command\EventCommand.java
``` java
 */
public class EventCommand extends Command {

	private static final String MESSAGE_EVENT_ADDED = "event added";
	private static final String MESSAGE_EVENT_CLASH = ". Another event exists on the same date.";
	private static final String MESSAGE_EVENT_ERROR = "unable to add event";

	/** Command parameters **/
	protected String title;
	protected CustomDate dateStart;
	protected CustomDate dateEnd;
	protected int startTime;
	protected int endTime;
	private Item event;

	/**
	 * Constructor for EventCommand objects. Checks if arguments are valid and
	 * stores the correct arguments properly. Throws the appropriate exception
	 * if arguments are invalid. Contains methods to add an event to storage.
	 * 
	 * @param args
	 * @param endTime
	 * @param startTime
	 * @param dateEnd
	 * @param dateStart
	 * @throws Exception
	 */
	public EventCommand(String title, CustomDate dateStart, CustomDate dateEnd,
			int startTime, int endTime) throws Exception {
		event = new Item();
		event.setType("event");
		event.setTitle(title);
		event.setStartDate(dateStart);
		event.setStartTime(startTime);
		event.setEndDate(dateEnd);
		event.setEndTime(endTime);
	}

	/**
	 * Checks if the event to be added clashes with another event and adds to
	 * the return message to inform the user
	 */
	private void checkEventClash() {
		if (isClashing()) {
			returnMsg += MESSAGE_EVENT_CLASH;
		}
	}

	/**
	 * get events list from storage
	 * 
	 * @return
	 */
	private ArrayList<Item> getEvents() {
		ArrayList<Item> events = Magical.getStorage().getList(
				Storage.EVENTS_INDEX);
		return events;
	}

	/**
	 * Checks if the current event to be added clashes with another event
	 * 
	 * @return
	 */
	private boolean isClashing() {
		ArrayList<Item> events = getEvents();
		for (Item t : events) {
			if (isTimeOverlap(t)) {
				return true;
			}
		}
		return false;
	}

	/**
	 * Checks if events overlap
	 * 
	 * @param t
	 * @return
	 */
	private boolean isTimeOverlap(Item t) {
		return t.getEndDate().equals(event.getEndDate());
	}

	public boolean isUndoable() {
		return true;
	}

	/**
	 * Stores the created Item Object as event
	 * 
	 * @throws IOException
	 */
	private void storeEvent() throws IOException {
		Magical.getStorage().create(Storage.EVENTS_INDEX, event);
		Magical.addDisplayList(Storage.EVENTS_INDEX, event);
	}

	/**
	 * Check if the end date given is after the start date
	 * 
	 * @return
	 */
	public boolean validDateRange() {
		return dateEnd.compareTo(dateStart) > 0;
	}

	/**
	 * Adds a new event to the storage using the parameters stored
	 * 
	 * @return message to show user
	 */
	public String execute() {
		try {
			returnMsg = MESSAGE_EVENT_ADDED;
			checkEventClash();
			storeEvent();
			return returnMsg;
		} catch (IOException e) {
			return MESSAGE_EVENT_ERROR;
		} finally {
			updateView();
			Magical.setCurrentTab("events");
		}
	}
}
```
###### command\ExitCommand.java
``` java
 */
public class ExitCommand extends Command {

	/**
	 * Constructor for ExitCommand objects. Arguments are stored but have no
	 * impact on command's functionality.
	 * 
	 * @throws Exception
	 */
	public ExitCommand() {

	}

	/**
	 * This method executes the exit command which terminates the program.
	 * 
	 * @return message to show user
	 */
	@Override
	public String execute() {
		System.exit(0);
		return null;
	}

	@Override
	public boolean isUndoable() {
		return false;
	}
}
```
###### command\HelpCommand.java
``` java
 */
public class HelpCommand extends Command {

	/**
	 * Constructor for HelpCommand objects. Arguments are stored but have no
	 * impact on command's functionality.
	 * 
	 * @throws Exception
	 */
	public HelpCommand() {

	}

	/**
	 * This method executes the help command. Which triggers the GUI to launch
	 * the help window.
	 * 
	 * @return message to show user
	 */
	@Override
	public String execute() throws Exception {
		Magical.setShowHelpWindow(true);
		return null;
	}

	@Override
	public boolean isUndoable() {
		return false;
	}
}
```
###### command\PathCommand.java
``` java
 */
public class PathCommand extends Command {

	private static final String MESSAGE_DIRECTORY_CHANGED = "Path changed to: %s";
	private static final String MESSAGE_DIRECTORY_MISSING = "%s (no such directory)";

	/** Messaging **/
	private static final String MESSAGE_ARGUMENT_FORMAT = "Use Format: path <location>";

	/** Command parameters **/
	private String location;

	/**
	 * Constructor for PathCommand objects. Checks if arguments are valid and
	 * stores the correct arguments properly. Throws the appropriate exception
	 * if arguments are invalid. Contains methods to change the file path
	 * location of storage textfile.
	 * 
	 * @param args
	 * @throws Exception
	 */
	public PathCommand(String location) throws Exception {
		this.location = location;
	}

	/**
	 * Throw exception if no location was specified
	 * 
	 * @throws IllegalArgumentException
	 */
	void checkLocation() throws IllegalArgumentException {
		if (location.isEmpty()) {
			throw new IllegalArgumentException(MESSAGE_ARGUMENT_FORMAT);
		}
	}

	/**
	 * This method executes the path command. Which changes the file path of the
	 * database file.
	 * 
	 * @return message to show user
	 */
	@Override
	public String execute() throws Exception {
		try {
			Magical.getStorage().changeFolderPath(location);
		} catch (FileNotFoundException fnfe) {
			throw new Exception(String.format(MESSAGE_DIRECTORY_MISSING,
					location));
		}
		return String.format(MESSAGE_DIRECTORY_CHANGED, location);
	}

	@Override
	public boolean isUndoable() {
		return true;
	}
}
```
###### command\PriorityCommand.java
``` java
 */
public class PriorityCommand extends Command {

	private static final String MESSAGE_PRIORITY_UPDATED = "Priority updated for %s";
	private static final String MESSAGE_PRIORITY_ERROR = "Unable to change priority for %s";

	/** Command parameters **/
	private Item item;
	private String itemID;
	private String priority;
	private Item prevItem;

	/**
	 * Constructor for PriorityCommand objects. Checks if arguments are valid
	 * and stores the correct arguments properly. Throws the appropriate
	 * exception if arguments are invalid. Contains methods to change the
	 * priority of an item.
	 * 
	 * @param args
	 * @param priority
	 * @param item
	 * @throws Exception
	 */
	public PriorityCommand(String itemID, Item item, String priority)
			throws Exception {
		this.itemID = itemID;
		this.item = item;
		this.priority = priority;
	}

	/**
	 * Make 2 copies of the item to be stored in prevItem and item
	 */
	void duplicateItem() {
		prevItem = item;
		item = prevItem.copy();
	}

	/**
	 * This method executes the priority command. Which simply changes the
	 * priority of the selected task or event to the new priority specified.
	 * 
	 * @return message to show user
	 * @throws Exception
	 */
	@Override
	public String execute() throws Exception {
		duplicateItem();
		item.setPriority(priority);

		try {
			updateItem();
		} catch (IOException e) {
			throw new Exception(String.format(MESSAGE_PRIORITY_ERROR, itemID));
		} finally {
			updateView();
		}

		return String.format(MESSAGE_PRIORITY_UPDATED, itemID);
	}

	@Override
	public boolean isUndoable() {
		return true;
	}

	/**
	 * Updates the original item with the new modified item
	 * 
	 * @throws IOException
	 */
	void updateItem() throws IOException {
		int listIndex = Storage.getListIndex(itemID);
		Magical.getStorage().update(listIndex, prevItem, item);
		Magical.updateDisplayList(listIndex, prevItem, item);
	}
}
```
###### command\RedoCommand.java
``` java
 */
public class RedoCommand extends Command {

	/** Messaging **/
	private static final String MESSAGE_REDO_ERROR = "Unable to redo";
	private static final String MESSAGE_REDO_SUCCESS = "Redo successful";
	private static final String MESSAGE_REDO_NONE = "Nothing to redo";

	/** Command parameters **/
	private int redoLayersSize;

	/**
	 * Constructor for RedoCommand objects. Arguments are stored but have no
	 * impact on command's functionality.
	 * 
	 * @param args
	 * @throws Exception
	 */
	public RedoCommand() {

	}

	/**
	 * Check if the last command is undoable. If it is, then storage was
	 * updated. Therefore, redo history should be reset and empty redo history
	 * message should be thrown.
	 * 
	 * @throws Exception
	 */
	void checkCanRedo() throws Exception {
		if (Magical.lastCommand.isUndoable()) {
			Magical.redoFolderPaths = new Stack<String>();
			Magical.redoLists.set(Storage.TASKS_INDEX,
					new Stack<ArrayList<Item>>());
			Magical.redoLists.set(Storage.TASKS_DONE_INDEX,
					new Stack<ArrayList<Item>>());
			Magical.redoLists.set(Storage.EVENTS_INDEX,
					new Stack<ArrayList<Item>>());
			Magical.redoLists.set(Storage.EVENTS_DONE_INDEX,
					new Stack<ArrayList<Item>>());
			throw new Exception(MESSAGE_REDO_NONE);
		}
	}

	/**
	 * Throw exception if there is nothing to redo
	 * 
	 * @param redoLayersSize
	 * @throws Exception
	 */
	void checkNumRedo() throws Exception {
		if (redoLayersSize <= 0) {
			throw new Exception(MESSAGE_REDO_NONE);
		}
	}

	/**
	 * This method executes the redo command. This command changes the storage
	 * to the version before undo was called. It fails if undo was never called
	 * or undo history got edited.
	 * 
	 * @return message to show user
	 * @throws Exception
	 */
	@Override
	public String execute() throws Exception {

		redoLayersSize = Magical.redoLists.get(0).size();
		checkNumRedo();
		checkCanRedo();

		try {
			Magical.pushUndoLayer();
			String folderPath = Magical.redoFolderPaths.pop();
			Magical.getStorage().changeFolderPath(folderPath);

			ArrayList<Item> nextTasksList = Magical.redoLists.get(
					Storage.TASKS_INDEX).pop();
			ArrayList<Item> nextTasksDoneList = Magical.redoLists.get(
					Storage.TASKS_DONE_INDEX).pop();
			ArrayList<Item> nextEventsList = Magical.redoLists.get(
					Storage.EVENTS_INDEX).pop();
			ArrayList<Item> nextEventsDoneList = Magical.redoLists.get(
					Storage.EVENTS_DONE_INDEX).pop();

			setStorageLists(nextTasksList, nextTasksDoneList, nextEventsList,
					nextEventsDoneList);

			return MESSAGE_REDO_SUCCESS;
		} catch (Exception e) {
			throw new Exception(MESSAGE_REDO_ERROR);
		} finally {
			if (Magical.lastViewCommand != null) {
				Magical.lastViewCommand.execute();
				updateView();
			} else {
				updateViewStorage();
			}
		}
	}

	@Override
	public boolean isUndoable() {
		return false;
	}

	/**
	 * Set the storage with the specified lists
	 * 
	 * @param nextTasksList
	 * @param nextTasksDoneList
	 * @param nextEventsList
	 * @param nextEventsDoneList
	 * @throws IOException
	 */
	void setStorageLists(ArrayList<Item> nextTasksList,
			ArrayList<Item> nextTasksDoneList, ArrayList<Item> nextEventsList,
			ArrayList<Item> nextEventsDoneList) throws IOException {
		Magical.getStorage().setList(Storage.TASKS_INDEX, nextTasksList);
		Magical.getStorage().setList(Storage.TASKS_DONE_INDEX,
				nextTasksDoneList);
		Magical.getStorage().setList(Storage.EVENTS_INDEX, nextEventsList);
		Magical.getStorage().setList(Storage.EVENTS_DONE_INDEX,
				nextEventsDoneList);
	}
}
```
###### command\SearchCommand.java
``` java
 */
public class SearchCommand extends Command {

	/** Messaging **/
	private static final String MESSAGE_SEARCH_SUCCESS = "search results for: [ %s ]";
	/** Command parameters **/
	private String query;

	/**
	 * Constructor for SearchCommand objects. Stores the correct arguments
	 * properly. Contains methods to display items containing query
	 * 
	 * @param args
	 * @throws Exception
	 */
	public SearchCommand(String query) throws Exception {
		assertNotNull(query);
		this.query = query.toLowerCase();
	}

	/**
	 * This method executes the search command. Which searches for the specified
	 * query text in the titles of all events and tasks. It then displays the
	 * found tasks and events to the GUI.
	 * 
	 * @return message to show user
	 */
	@Override
	public String execute() {
		ArrayList<Item> taskList = Magical.getStorage().getList(
				Storage.TASKS_INDEX);
		ArrayList<Item> taskDoneList = Magical.getStorage().getList(
				Storage.TASKS_DONE_INDEX);
		ArrayList<Item> eventList = Magical.getStorage().getList(
				Storage.EVENTS_INDEX);
		ArrayList<Item> eventDoneList = Magical.getStorage().getList(
				Storage.EVENTS_DONE_INDEX);

		ArrayList<Item> filteredTaskList = filterList(taskList);
		ArrayList<Item> filteredTaskDoneList = filterList(taskDoneList);
		ArrayList<Item> filteredEventList = filterList(eventList);
		ArrayList<Item> filteredEventDoneList = filterList(eventDoneList);

		updateView(filteredTaskList, filteredTaskDoneList, filteredEventList,
				filteredEventDoneList);

		return String.format(MESSAGE_SEARCH_SUCCESS, query);
	}

	/**
	 * Filter items according to query in the given list and return it
	 * 
	 * @param itemList
	 * @return filtered list to show user
	 */
	private ArrayList<Item> filterList(ArrayList<Item> itemList) {
		ArrayList<Item> filteredItemList = new ArrayList<Item>();
		for (Item i : itemList) {
			if (i.getTitle().contains(query)) {
				filteredItemList.add(i);
			}
		}
		return filteredItemList;
	}

	@Override
	public boolean isUndoable() {
		return false;
	}
}
```
###### command\ShowCommand.java
``` java
 */
public class ShowCommand extends Command {

	/** Messaging **/
	private static final String MESSAGE_SHOW_RESULTS = "Show results for: %s";

	/** Command parameters **/
	private ArrayList<String> tags;
	private String type;

	/**
	 * Constructor for ShowCommand objects. Sets the command parameters with the
	 * proper inputs. Contains methods to display items that are tasks, events,
	 * containing specified tags, or all items
	 * 
	 * @param args
	 * @param tags2
	 * @throws Exception
	 */
	public ShowCommand(String type, ArrayList<String> tags) throws Exception {
		this.type = type;
		this.tags = tags;
	}

	/**
	 * This method executes the show command. Which filters the database
	 * according to the parameters specified. It then shows a subset of tasks
	 * and events to the GUI. The valid parameters are either (1) "title" (2)
	 * "event" OR (3) a list of tags.
	 * 
	 * @return message to show user
	 */
	@Override
	public String execute() {
		ArrayList<Item> taskList = Magical.getStorage().getList(
				Storage.TASKS_INDEX);
		ArrayList<Item> taskDoneList = Magical.getStorage().getList(
				Storage.TASKS_DONE_INDEX);
		ArrayList<Item> eventList = Magical.getStorage().getList(
				Storage.EVENTS_INDEX);
		ArrayList<Item> eventDoneList = Magical.getStorage().getList(
				Storage.EVENTS_DONE_INDEX);

		ArrayList<Item> showTaskList = new ArrayList<Item>(taskList);
		ArrayList<Item> showTaskDoneList = new ArrayList<Item>(taskDoneList);
		ArrayList<Item> showEventList = new ArrayList<Item>(eventList);
		ArrayList<Item> showEventDoneList = new ArrayList<Item>(eventDoneList);

		switch (type) {
		case "all":
			showTaskList = taskList;
			showTaskDoneList = taskDoneList;
			showEventList = eventList;
			showEventDoneList = eventDoneList;
			break;
		case "task":
			Magical.setCurrentTab("tasks");
			break;
		case "tasks":
			Magical.setCurrentTab("tasks");
			break;
		case "event":
			Magical.setCurrentTab("events");
			break;
		case "events":
			Magical.setCurrentTab("events");
			break;
		case "tag":
			showTaskList = filterList(taskList);
			showTaskDoneList = filterList(taskDoneList);
			showEventList = filterList(eventList);
			showEventDoneList = filterList(eventDoneList);
			break;
		default:
			break;
		}

		updateView(showTaskList, showTaskDoneList, showEventList,
				showEventDoneList);

		return String.format(MESSAGE_SHOW_RESULTS, tags);
	}

	/**
	 * Filter items according to tag in the given list and return it
	 * 
	 * @param itemList
	 * @return filtered list to show user
	 */
	private ArrayList<Item> filterList(ArrayList<Item> itemList) {
		ArrayList<Item> filteredItemList = new ArrayList<Item>();
		Set<String> queryTags = new HashSet<String>();
		for (String tag : tags) {
			queryTags.add(tag.toLowerCase());
		}
		for (Item i : itemList) {
			if (i.getTags().containsAll(queryTags)) {
				filteredItemList.add(i);
			}
		}
		return filteredItemList;
	}

	@Override
	public boolean isUndoable() {
		return false;
	}
}
```
###### command\SortCommand.java
``` java
 */
public class SortCommand extends Command {

	private static final String MESSAGE_SORT_SUCCESS = "sort successful";

	/** Command parameters **/
	private ArrayList<String> sortParams;

	/**
	 * Constructor for SortCommand objects. Checks if arguments are valid and
	 * stores the correct arguments properly. Throws the appropriate exception
	 * if arguments are invalid. Contains methods to sort the displayed tasks.
	 * 
	 * @param sortParams
	 * @throws Exception
	 */
	public SortCommand(ArrayList<String> sortParams) throws Exception {
		this.sortParams = sortParams;
	}

	/**
	 * This method executes the sort command. Which sorts all the tasks and
	 * events currently displayed by the GUI. Sorting is done using the
	 * parameter specified.
	 * 
	 * @return message to show user
	 */
	@Override
	public String execute() throws Exception {

		ArrayList<Item> sortedTaskList = new ArrayList<Item>(
				Magical.getDisplayList(Storage.TASKS_INDEX));
		ArrayList<Item> sortedTaskDoneList = new ArrayList<Item>(
				Magical.getDisplayList(Storage.TASKS_DONE_INDEX));
		ArrayList<Item> sortedEventList = new ArrayList<Item>(
				Magical.getDisplayList(Storage.EVENTS_INDEX));
		ArrayList<Item> sortedEventDoneList = new ArrayList<Item>(
				Magical.getDisplayList(Storage.EVENTS_DONE_INDEX));

		if (sortParams.contains("title")) {
			Collections.sort(sortedTaskList, Item.Comparators.TITLE);
			Collections.sort(sortedTaskDoneList, Item.Comparators.TITLE);
			Collections.sort(sortedEventList, Item.Comparators.TITLE);
			Collections.sort(sortedEventDoneList, Item.Comparators.TITLE);
		}
		if (sortParams.contains("date")) {
			Collections.sort(sortedTaskList, Item.Comparators.DATE);
			Collections.sort(sortedTaskDoneList, Item.Comparators.DATE);
			Collections.sort(sortedEventList, Item.Comparators.DATE);
			Collections.sort(sortedEventDoneList, Item.Comparators.DATE);
		}
		if (sortParams.contains("priority")) {
			Collections.sort(sortedTaskList, Item.Comparators.PRIORITY);
			Collections.sort(sortedTaskDoneList, Item.Comparators.PRIORITY);
			Collections.sort(sortedEventList, Item.Comparators.PRIORITY);
			Collections.sort(sortedEventDoneList, Item.Comparators.PRIORITY);
		}

		updateView(sortedTaskList, sortedTaskDoneList, sortedEventList,
				sortedEventDoneList);

		return MESSAGE_SORT_SUCCESS;
	}

	@Override
	public boolean isUndoable() {
		return false;
	}
}
```
###### command\TagCommand.java
``` java
 */
public class TagCommand extends Command {

	private static final String MESSAGE_TAG_ERROR = "Unable to add tag to %s";
	private static final String MESSAGE_TAG_ADDED = "%s added to %s";

	/** Command Parameters **/
	private Item item;
	private String itemID;
	private ArrayList<String> tags;
	private Item prevItem;

	/**
	 * Constructor for TagCommand objects. Checks if arguments are valid and
	 * stores the correct arguments properly. Throws the appropriate exception
	 * if arguments are invalid
	 * 
	 * @param args
	 * @param tags2
	 * @param item2
	 * @throws Exception
	 */
	public TagCommand(String itemID, Item item, ArrayList<String> tags)
			throws Exception {
		this.itemID = itemID;
		this.item = item;
		this.tags = tags;
	}

	/**
	 * Adds given tag to set of tags and set item tags as this set
	 * 
	 * @param currentTags
	 * @param tag
	 */
	void addTagToItem(Set<String> currentTags, String tag) {
		currentTags.add(tag.toLowerCase());
		item.setTags(currentTags);
	}

	/**
	 * Make 2 copies of the item to be stored in prevItem and item
	 */
	void duplicateItem() {
		prevItem = item;
		item = prevItem.copy();
	}

	/**
	 * This method executes the tag command. Which simply adds the specified tag
	 * to a task or event's tag set.
	 * 
	 * @return message to show user
	 * @throws Exception
	 */
	@Override
	public String execute() throws Exception {

		duplicateItem();
		Set<String> currentTags = item.getTags();
		for (String tag : tags) {
			addTagToItem(currentTags, tag);
		}

		try {
			updateItem();
		} catch (IOException e) {
			return String.format(MESSAGE_TAG_ERROR, itemID);
		} finally {
			updateView();
		}

		return String.format(MESSAGE_TAG_ADDED, tags, itemID);
	}

	@Override
	public boolean isUndoable() {
		return true;
	}

	/**
	 * Updates the original item with the new modified item
	 * 
	 * @throws IOException
	 */
	void updateItem() throws IOException {
		int listIndex = Storage.getListIndex(itemID);
		Magical.getStorage().update(listIndex, prevItem, item);
		Magical.updateDisplayList(listIndex, prevItem, item);
	}
}
```
###### command\UndoCommand.java
``` java
 */
public class UndoCommand extends Command {

	/** Messaging **/
	private static final String MESSAGE_UNDO_ERROR = "Unable to undo";
	private static final String MESSAGE_UNDO_SUCCESS = "Undo successful";
	private static final String MESSAGE_UNDO_NONE = "nothing to undo";

	/** Command parameters **/
	private int undoLayersSize;

	/**
	 * Constructor for UndoCommand objects. Arguments are stored but have no
	 * impact on command's functionality.
	 * 
	 * @param args
	 * @throws Exception
	 */
	public UndoCommand() {

	}

	/**
	 * This method executes the undo command. Whenever a command which alters
	 * the database is executed, a new layer of history is created so that the
	 * command's actions can be undo. If a previous version of the database
	 * exists, this command reverts the database to the previous version.
	 * 
	 * @return message to show user
	 * @throws Exception
	 */
	@Override
	public String execute() throws Exception {
		undoLayersSize = Magical.undoLists.get(0).size();
		checkNumUndo();

		try {
			backUpToRedo();
			moveUndoToStorage();

			ArrayList<Item> lastTasksList = Magical.undoLists.get(
					Storage.TASKS_INDEX).pop();
			ArrayList<Item> lastTasksDoneList = Magical.undoLists.get(
					Storage.TASKS_DONE_INDEX).pop();
			ArrayList<Item> lastEventsList = Magical.undoLists.get(
					Storage.EVENTS_INDEX).pop();
			ArrayList<Item> lastEventsDoneList = Magical.undoLists.get(
					Storage.EVENTS_DONE_INDEX).pop();

			setStorage(lastTasksList, lastTasksDoneList, lastEventsList,
					lastEventsDoneList);

			return MESSAGE_UNDO_SUCCESS;
		} catch (Exception e) {
			throw new Exception(MESSAGE_UNDO_ERROR);
		} finally {
			if (Magical.lastViewCommand != null) {
				Magical.lastViewCommand.execute();
				updateView();
			} else {
				updateViewStorage();
			}
		}
	}

	/**
	 * Move undo stack to storage
	 * 
	 * @throws IOException
	 * @throws FileNotFoundException
	 */
	void moveUndoToStorage() throws IOException, FileNotFoundException {
		String folderPath = Magical.undoFolderPaths.pop();
		Magical.getStorage().changeFolderPath(folderPath);
	}

	/**
	 * Back up storage to redo stack
	 */
	void backUpToRedo() {
		Magical.redoFolderPaths.push(Magical.getStorage().getFolderPath());
		Magical.redoLists.get(Storage.TASKS_INDEX).push(
				Magical.getStorage().getList(Storage.TASKS_INDEX));
		Magical.redoLists.get(Storage.TASKS_DONE_INDEX).push(
				Magical.getStorage().getList(Storage.TASKS_DONE_INDEX));
		Magical.redoLists.get(Storage.EVENTS_INDEX).push(
				Magical.getStorage().getList(Storage.EVENTS_INDEX));
		Magical.redoLists.get(Storage.EVENTS_DONE_INDEX).push(
				Magical.getStorage().getList(Storage.EVENTS_DONE_INDEX));
	}

	/**
	 * Set the storage with the specified lists
	 * 
	 * @param lastTasksList
	 * @param lastTasksDoneList
	 * @param lastEventsList
	 * @param lastEventsDoneList
	 * @throws IOException
	 */
	void setStorage(ArrayList<Item> lastTasksList,
			ArrayList<Item> lastTasksDoneList, ArrayList<Item> lastEventsList,
			ArrayList<Item> lastEventsDoneList) throws IOException {
		Magical.getStorage().setList(Storage.TASKS_INDEX, lastTasksList);
		Magical.getStorage().setList(Storage.TASKS_DONE_INDEX,
				lastTasksDoneList);
		Magical.getStorage().setList(Storage.EVENTS_INDEX, lastEventsList);
		Magical.getStorage().setList(Storage.EVENTS_DONE_INDEX,
				lastEventsDoneList);
	}

	/**
	 * Throw exception if there is nothing to undo
	 * 
	 * @param redoLayersSize
	 * @throws Exception
	 */
	void checkNumUndo() throws Exception {
		if (undoLayersSize <= 0) {
			throw new Exception(MESSAGE_UNDO_NONE);
		}
	}

	@Override
	public boolean isUndoable() {
		return false;
	}
}
```
###### command\UndoneCommand.java
``` java
 */
public class UndoneCommand extends Command {

	private static final String MESSAGE_UNDONE_SUCCESS = "Item un-archived";
	private static final String MESSAGE_UNDONE_ERROR = "Unable to un-archive %s";

	/** Command Parameters **/
	private Item item;
	private String itemID;

	/**
	 * Constructor for DoneCommand objects. Checks if arguments are valid and
	 * stores the correct arguments properly. Throws the appropriate exception
	 * if arguments are invalid. Contains methods to move item to undone list.
	 * 
	 * @param args
	 * @param item
	 * @throws Exception
	 */
	public UndoneCommand(String itemID, Item item) throws Exception {
		this.itemID = itemID;
		this.item = item;
	}

	/**
	 * This method creates a executes the undone command. Which simply moves
	 * either (1) a done task to the not-done pile or (2) a done event to the
	 * not-done pile
	 * 
	 * @return message to show user
	 */
	public String execute() {
		try {
			undoneItem();
		} catch (IOException e) {
			return String.format(MESSAGE_UNDONE_ERROR, itemID);
		} finally {
			updateView();
		}

		return MESSAGE_UNDONE_SUCCESS;
	}

	@Override
	public boolean isUndoable() {
		return true;
	}

	/**
	 * This method executes the undone command. Which either moves a task or
	 * event to its corresponding undone task or undone event pile.
	 */
	void undoneItem() throws IOException {
		int listIndex = Storage.getListIndex(itemID);
		int complementListIndex = Storage.getComplementListIndex(listIndex);
		Magical.getStorage().delete(listIndex, item);
		Magical.getStorage().create(complementListIndex, item);
		Magical.deleteDisplayList(listIndex, item);
		Magical.addDisplayList(complementListIndex, item);
	}
}
```
###### command\UntagCommand.java
``` java
 */
public class UntagCommand extends Command {

	private static final String MESSAGE_TAG_ERROR = "Unable to remove tag to %s";
	private static final String MESSAGE_TAG_REMOVED = "%s removed from %s";

	/** Command Parameters **/
	private Item item;
	private String itemID;
	private ArrayList<String> tags;
	private Item prevItem;

	/**
	 * Constructor for UntagCommand objects. Checks if arguments are valid and
	 * stores the correct arguments properly. Throws the appropriate exception
	 * if arguments are invalid
	 * 
	 * @param args
	 * @param tags
	 * @param item
	 * @throws Exception
	 */
	public UntagCommand(String itemID, Item item, ArrayList<String> tags)
			throws Exception {
		this.itemID = itemID;
		this.item = item;
		this.tags = tags;
	}

	/**
	 * Make 2 copies of the item to be stored in prevItem and item
	 */
	void duplicateItem() {
		prevItem = item;
		item = prevItem.copy();
	}

	/**
	 * This method executes the untag command. Which simply removes the
	 * specified tags from a task or event's tag set.
	 * 
	 * @param None
	 * @return message to show user
	 * @throws Exception
	 */
	@Override
	public String execute() throws Exception {
		duplicateItem();
		Set<String> currentTags = item.getTags();

		for (String tag : tags) {
			removeTagFromItem(currentTags, tag);
		}

		try {
			updateItem();
		} catch (IOException e) {
			throw new Exception(String.format(MESSAGE_TAG_ERROR, itemID));
		} finally {
			updateView();
		}

		return String.format(MESSAGE_TAG_REMOVED, tags, itemID);
	}

	@Override
	public boolean isUndoable() {
		return true;
	}

	/**
	 * Removes given tag from set of tags and set item tags as this set
	 * 
	 * @param currentTags
	 * @param tag
	 */
	void removeTagFromItem(Set<String> currentTags, String tag) {
		currentTags.remove(tag.toLowerCase());
		item.setTags(currentTags);
	}

	/**
	 * Updates the original item with the new modified item
	 * 
	 * @throws IOException
	 */
	void updateItem() throws IOException {
		int listIndex = Storage.getListIndex(itemID);
		Magical.getStorage().update(listIndex, prevItem, item);
		Magical.updateDisplayList(listIndex, prevItem, item);
	}
}
```
###### main\Item.java
``` java
 * @author Varun Patro
 */
public class Item {

	/**
	 * Comparators for ordering items in different indexes
	 */
	public static class Comparators {
		public static final Comparator<Item> PRIORITY = new Comparator<Item>() {
			@Override
			public int compare(Item i1, Item i2) {
				int i1p, i2p = 0;
				if (i1.priority == null) {
					i1p = 0;
				} else if (i1.priority.equals("high")) {
					i1p = 3;
				} else if (i1.priority.equals("medium")) {
					i1p = 2;
				} else if (i1.priority.equals("low")) {
					i1p = 1;
				} else {
					i1p = 0;
				}
				if (i2.priority == null) {
					i2p = 0;
				} else if (i2.priority.equals("high")) {
					i2p = 3;
				} else if (i2.priority.equals("medium")) {
					i2p = 2;
				} else if (i2.priority.equals("low")) {
					i2p = 1;
				} else {
					i2p = 0;
				}
				return Integer.compare(i2p, i1p);
			}
		};
		public static final Comparator<Item> DATE = new Comparator<Item>() {
			@Override
			public int compare(Item i1, Item i2) {
				if (i1.endDate == null && i2.endDate == null) {
					return 0;
				}
				if (i1.endDate == null) {
					return 1;
				}
				if (i2.endDate == null) {
					return -1;
				}
				return i1.endDate.getDate().compareTo(i2.endDate.getDate());
			}
		};
		public static final Comparator<Item> TITLE = (Item i1, Item i2) -> i1.title
				.compareTo(i2.title);
	}

	private String type;
	private String title;
	private CustomDate startDate;
	private CustomDate endDate;
	private int startTime;
	private int endTime;
	private Set<String> tags = new HashSet<String>();
	private String priority;

	/**
	 * Method to deep copy this item
	 * 
	 * @return a deep copy of this item
	 */
	public Item copy() {
		Item copyTask = new Item();
		copyTask.setType(this.type);
		copyTask.setTitle(this.title);
		CustomDate sd = this.startDate != null ? new CustomDate(
				this.startDate.getDate()) : null;
		CustomDate ed = this.endDate != null ? new CustomDate(
				this.endDate.getDate()) : null;
		copyTask.setStartDate(sd);
		copyTask.setEndDate(ed);
		copyTask.setStartTime(this.startTime);
		copyTask.setEndTime(this.endTime);
		Set<String> copyTags = new HashSet<String>();
		for (String tag : this.tags) {
			copyTags.add(tag);
		}
		copyTask.setTags(copyTags);
		copyTask.setPriority(this.priority);
		return copyTask;
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		Item other = (Item) obj;
		if (endDate == null) {
			if (other.endDate != null)
				return false;
		} else if (!endDate.equals(other.endDate))
			return false;
		if (endTime != other.endTime)
			return false;
		if (priority == null) {
			if (other.priority != null)
				return false;
		} else if (!priority.equals(other.priority))
			return false;
		if (startDate == null) {
			if (other.startDate != null)
				return false;
		} else if (!startDate.equals(other.startDate))
			return false;
		if (startTime != other.startTime)
			return false;
		if (tags == null) {
			if (other.tags != null)
				return false;
		} else if (!tags.equals(other.tags))
			return false;
		if (title == null) {
			if (other.title != null)
				return false;
		} else if (!title.equals(other.title))
			return false;
		if (type == null) {
			if (other.type != null)
				return false;
		} else if (!type.equals(other.type))
			return false;
		return true;
	}

	/**
	 * Getter for end date.
	 */
	public CustomDate getEndDate() {
		return endDate;
	}

	/**
	 * Getter for end time.
	 */
	public int getEndTime() {
		return endTime;
	}

	/**
	 * Getter for priority.
	 */
	public String getPriority() {
		return priority;
	}

	/**
	 * Getter for start date.
	 */
	public CustomDate getStartDate() {
		return startDate;
	}

	/**
	 * Getter for start time.
	 */
	public int getStartTime() {
		return startTime;
	}

	/**
	 * Getter for tags.
	 */
	public Set<String> getTags() {
		return tags;
	}

	/**
	 * Getter for title.
	 */
	public String getTitle() {
		return title;
	}

	/**
	 * Getter for type.
	 */
	public String getType() {
		return type;
	}

	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + ((endDate == null) ? 0 : endDate.hashCode());
		result = prime * result + endTime;
		result = prime * result
				+ ((priority == null) ? 0 : priority.hashCode());
		result = prime * result
				+ ((startDate == null) ? 0 : startDate.hashCode());
		result = prime * result + startTime;
		result = prime * result + ((tags == null) ? 0 : tags.hashCode());
		result = prime * result + ((title == null) ? 0 : title.hashCode());
		result = prime * result + ((type == null) ? 0 : type.hashCode());
		return result;
	}

	/**
	 * Setter for end date.
	 */
	public void setEndDate(CustomDate endDate) {
		this.endDate = endDate;
	}

	/**
	 * Setter for end time.
	 */
	public void setEndTime(int endTime) {
		this.endTime = endTime;
	}

	/**
	 * Setter for priority.
	 */
	public void setPriority(String priority) {
		this.priority = priority;
	}

	/**
	 * Setter for start date.
	 */
	public void setStartDate(CustomDate startDate) {
		this.startDate = startDate;
	}

	/**
	 * Setter for start time.
	 */
	public void setStartTime(int startTime) {
		this.startTime = startTime;
	}

	/**
	 * Setter for tags.
	 */
	public void setTags(Set<String> tags) {
		this.tags = tags;
	}

	/**
	 * Setter for title.
	 */
	public void setTitle(String title) {
		this.title = title;
	}

	/**
	 * Setter for type.
	 */
	public void setType(String type) {
		this.type = type;
	}
}
```
###### main\Magical.java
``` java
 * @author Varun Patro
 */
public class Magical {
	private static Storage storage;
	private static List<ArrayList<Item>> displayLists;
	private static String currentTab;
	private static boolean showHelpWindow;

	public static List<Stack<ArrayList<Item>>> undoLists = new ArrayList<Stack<ArrayList<Item>>>(
			Storage.NUM_LISTS);
	public static List<Stack<ArrayList<Item>>> redoLists = new ArrayList<Stack<ArrayList<Item>>>(
			Storage.NUM_LISTS);

	public static Stack<String> undoFolderPaths = new Stack<String>();

	public static Stack<String> redoFolderPaths = new Stack<String>();

	public static Command lastCommand;
	public static Command lastViewCommand;

	/**
	 * This method adds a specified Item in the list of Items where the Item is
	 * stored in and updates the data file.
	 * 
	 * @param listIndex
	 *            Index of the list where the Item to be updated is stored in.
	 * @param t
	 *            The updated Item to be stored.
	 */
	public static void addDisplayList(int listIndex, Item item) {
		displayLists.get(listIndex).add(item);
	}

	/**
	 * This method archives all events that ended before the current date.
	 */
	private static void archivePastEvents() {
		ArrayList<Item> eventList = storage.getList(Storage.EVENTS_INDEX);
		ArrayList<Item> eventDoneList = storage
				.getList(Storage.EVENTS_DONE_INDEX);
		ArrayList<Item> newEventList = new ArrayList<Item>();
		CustomDate today = new CustomDate();
		for (int i = 0; i < eventList.size(); i++) {
			Item item = eventList.get(i);
			CustomDate d = item.getEndDate();
			if (d.compareTo(today) < 0) {
				eventDoneList.add(item);
			} else {
				newEventList.add(item);
			}
		}
		try {
			storage.setList(Storage.EVENTS_INDEX, newEventList);
			storage.setList(Storage.EVENTS_DONE_INDEX, eventDoneList);
		} catch (IOException e) {
		}
	}

	/**
	 * This method deletes a specified Item in the list of Items where the Item
	 * is stored in and updates the data file.
	 * 
	 * @param listIndex
	 *            Index of the list where the Item to be updated is stored in.
	 * @param t
	 *            The updated Item to be stored.
	 */
	public static void deleteDisplayList(int listIndex, Item item) {
		int pos = displayLists.get(listIndex).indexOf(item);
		if (pos > -1) {
			displayLists.get(listIndex).remove(pos);
		}
	}

	/**
	 * This method reads makes use of the Parser to create the relevant command.
	 * The command is then executed and its result is returned.
	 * 
	 * @param userInput
	 * @return message to display
	 * @exception Exception
	 */
	public static String execute(String userInput) throws Exception {
		Parser p = Parser.getInstance();
		Command command = p.parse(userInput);
		if (command.isUndoable()) {
			pushUndoLayer();
		}
		String message = command.execute();
		lastCommand = command;
		if ((command instanceof ShowCommand)
				|| (command instanceof SearchCommand)
				|| (command instanceof DateCommand)) {
			lastViewCommand = command;
		}
		return message;
	}

	/**
	 * Getter for currentTab.
	 * 
	 * @return current tab
	 */
	public static String getCurrentTab() {
		return currentTab;
	}

	/**
	 * Getter for display list.
	 * 
	 * @param index
	 * @return corresponding list of items to return
	 */
	public static ArrayList<Item> getDisplayList(int index) {
		return displayLists.get(index);
	}

	/**
	 * Getter for storage.
	 * 
	 * @return active instance of Storage
	 */
	public static Storage getStorage() {
		return storage;
	}

	/**
	 * This method initializes the Magical class by initializing the storage,
	 * undo and redo history. It also initializes the displayList with the items
	 * in storage.
	 */
	public static void init() {
		storage = new Storage();
		currentTab = "tasks";
		archivePastEvents();
		displayLists = new ArrayList<ArrayList<Item>>(Storage.NUM_LISTS);
		for (int i = 0; i < Storage.NUM_LISTS; i++) {
			displayLists.add(listClone(storage.getList(i)));
		}
		for (int i = 0; i < Storage.NUM_LISTS; i++) {
			undoLists.add(new Stack<ArrayList<Item>>());
		}
		for (int i = 0; i < Storage.NUM_LISTS; i++) {
			redoLists.add(new Stack<ArrayList<Item>>());
		}
	}

	/**
	 * Getter for show help window
	 * 
	 * @return
	 */
	public static boolean isShowHelpWindow() {
		return showHelpWindow;
	}

	/**
	 * This method is used to deep clone an ArrayList of Items. Used for
	 * creating undo layers of storage.
	 * 
	 * @param list
	 *            List to clone
	 * @return clonedList
	 */
	private static ArrayList<Item> listClone(ArrayList<Item> list) {
		ArrayList<Item> newList = new ArrayList<Item>(list.size());
		try {
			for (Item i : list) {
				newList.add(i.copy());
			}
			return newList;
		} catch (Exception e) {
			return list;
		}
	}

	/**
	 * This method takes a snapshot of the current storage. This is known as
	 * pushing an undo layer onto the undo history stack.
	 */
	public static void pushUndoLayer() {
		undoFolderPaths.push(storage.getFolderPath());
		ArrayList<Item> prevTasksList = listClone(storage
				.getList(Storage.TASKS_INDEX));
		ArrayList<Item> prevTasksDoneList = listClone(storage
				.getList(Storage.TASKS_DONE_INDEX));
		ArrayList<Item> prevEventsList = listClone(storage
				.getList(Storage.EVENTS_INDEX));
		ArrayList<Item> prevEventsDoneList = listClone(storage
				.getList(Storage.EVENTS_DONE_INDEX));
		undoLists.get(Storage.TASKS_INDEX).push(prevTasksList);
		undoLists.get(Storage.TASKS_DONE_INDEX).push(prevTasksDoneList);
		undoLists.get(Storage.EVENTS_INDEX).push(prevEventsList);
		undoLists.get(Storage.EVENTS_DONE_INDEX).push(prevEventsDoneList);
	}

	/**
	 * Setter for currenTab.
	 * 
	 * @param currentTab
	 */
	public static void setCurrentTab(String currentTab) {
		Magical.currentTab = currentTab;
	}

	/**
	 * Setter for display list.
	 * 
	 * @param index
	 * @param newList
	 */
	public static void setDisplayList(int index, ArrayList<Item> newList) {
		displayLists.set(index, listClone(newList));
	}

	/**
	 * Setter for show help window
	 * 
	 * @param showHelpWindow
	 */
	public static void setShowHelpWindow(boolean showHelpWindow) {
		Magical.showHelpWindow = showHelpWindow;
	}

	/**
	 * This method updates a specified Item in the list of Items where the Item
	 * is stored in and updates the data file.
	 * 
	 * @param listIndex
	 *            Index of the list where the Item to be updated is stored in.
	 * @param t
	 *            The updated Item to be stored.
	 */
	public static void updateDisplayList(int listIndex, Item oldItem,
			Item newItem) {
		int pos = displayLists.get(listIndex).indexOf(oldItem);
		if (pos > -1) {
			displayLists.get(listIndex).set(pos, newItem);
		}
	}
}
```
###### main\Storage.java
``` java
	 */
	public static int getComplementListIndex(int index) {
		switch (index) {
		case TASKS_INDEX:
			return TASKS_DONE_INDEX;
		case TASKS_DONE_INDEX:
			return TASKS_INDEX;
		case EVENTS_INDEX:
			return EVENTS_DONE_INDEX;
		case EVENTS_DONE_INDEX:
			return EVENTS_INDEX;
		default:
			return -1;
		}
	}

	/**
	 * This method retrieves the list index of the list wanted.
	 * 
	 * @param id
	 *            ID of the list wanted.
	 * @return Integer value of list index.
```
###### main\Storage.java
``` java
	 */
	public static int getListIndex(String id) {
		switch (id.charAt(0)) {
		case 't':
			return TASKS_INDEX;
		case 'd':
			return TASKS_DONE_INDEX;
		case 'e':
			return EVENTS_INDEX;
		case 'p':
			return EVENTS_DONE_INDEX;
		default:
			return -1;
		}
	}

	/**
	 * This method changes the file path stored in the properties file and moves
	 * the .txt data file to the specified new file path.
	 * 
	 * @param newFolderPath
	 *            New file path specified by user.
	 * @return Whether the file path is changed successfully or not.
	 * @throws IOException.
	 * @throws FileNotFoundException.
```
###### main\Storage.java
``` java
	 */
	protected void clear(int listIndex) throws IOException {
		lists.set(listIndex, new ArrayList<Item>());
		writeLists();
	}

	/**
	 * This method stores a Item object into the specified list and updates the
	 * data file.
	 * 
	 * @param listIndex
	 *            list index of the list to store the Item into.
	 * @param t
	 *            Item object to store into the list.
	 * @throws IOException
	 *             On file input error.
```
###### main\Storage.java
``` java
	 */
	public void delete(int listIndex, Item item) throws IOException {
		int pos = getPos(listIndex, item);
		if (pos > -1) {
			lists.get(listIndex).remove(pos);
			writeLists();
		}
	}

	/**
	 * This method checks whether the data file exist or not.
	 * 
	 * @return whether file exists.
```
###### main\Storage.java
``` java
	 */
	public ArrayList<Item> getList(int listIndex) {
		return lists.get(listIndex);
	}

	/**
	 * This method retrieves the list containing all lists of Item objects.
	 * 
	 * @return The list containing all lists of Item objects.
```
###### main\Storage.java
``` java
	 */
	protected List<ArrayList<Item>> getLists() {
		return lists;
	}

	/**
	 * This method retrieves the position of a specified Item in the list it is
	 * stored in.
	 * 
	 * @param listIndex
	 *            Index of the list that the Item is stored in.
	 * @param t
	 *            Item object that you want to get the position of.
	 * @return Position of the Item in the list it is stored in. (0-based)
```
###### main\Storage.java
``` java
	 */
	protected int getPos(int listIndex, Item item) {
		return lists.get(listIndex).indexOf(item);
	}

	/**
	 * This method initialises the .txt data file. If the file doesn't exist,
	 * the data file is created and data is written into it. Else if the data
	 * file exist, data is being read and stored in the program.
	 * 
	 * @exception IOException
	 *                On file input error.
	 * @see IOException.
```
###### main\Storage.java
``` java
	 */
	public void setList(int listIndex, ArrayList<Item> list) throws IOException {
		lists.set(listIndex, list);
		writeLists();
	}

	/**
	 * This method updates a specified Item in the list of Items where the Item
	 * is stored in and updates the data file.
	 * 
	 * @param listIndex
	 *            Index of the list where the Item to be updated is stored in.
	 * @param t
	 *            The updated Item to be stored.
	 * @throws IOException
	 *             On file input error.
```
###### main\Storage.java
``` java
	 */
	public void update(int listIndex, Item oldItem, Item newItem)
			throws IOException {
		int pos = getPos(listIndex, oldItem);
		if (pos > -1) {
			lists.get(listIndex).set(pos, newItem);
			writeLists();
		}
	}

	/**
	 * This method writes all current content from the program into the .txt
	 * data file.
	 * 
	 * @throws IOException
	 *             On file input error.
```
