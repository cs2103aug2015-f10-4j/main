# A0129654X
###### main\CustomDate.java
``` java
 */
public class CustomDate implements Comparable<CustomDate> {

	/** Messaging **/
	private static final String DATE_FORMAT = "%s on %d %s %s, %s";
	private static final String[] dayArray = { "Sun", "Mon", "Tue", "Wed",
			"Thu", "Fri", "Sat" };

	private static final String[] monthArray = { "Jan", "Feb", "Mar", "Apr",
			"May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" };

	/** CustomDate parameters **/
	private Date date;

	/**
	 * Constructor for CustomDate. Uses the current date as the date object for
	 * the CustomDate.
	 */
	public CustomDate() {
		this.date = new Date();
	}

	/**
	 * Constructor for CustomDate. Takes in a date object for use by the
	 * CustomDate.
	 *
	 * @param date
	 */
	public CustomDate(Date date) {
		this.date = date;
	}

	public int compareTo(CustomDate that) {
		if (this.getDate() == null && that.getDate() == null) {
			return 0;
		} else if (this.getDate() == null) {
			return -1;
		} else if (that.getDate() == null) {
			return 1;
		}
		return this.getDate().compareTo(that.getDate());
	}

	/**
	 * Create a calendar for get methods
	 *
	 * @return
	 */
	Calendar createCal() {
		Calendar cal = Calendar.getInstance();
		cal.setTime(date);
		return cal;
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj) {
			return true;
		}
		if (obj == null) {
			return false;
		}
		if (!(obj instanceof CustomDate)) {
			return false;
		}
		CustomDate other = (CustomDate) obj;
		if (date == null) {
			if (other.date != null) {
				return false;
			}
		} else if (!date.equals(other.date)) {
			return false;
		}
		return true;
	}

	/**
	 * Returns date object of the CustomDate
	 *
	 * @return
	 */
	public Date getDate() {
		return this.date;
	}

	/**
	 * Returns the date as a string in dd/MM/yyyy format
	 *
	 * @return
	 */
	public String getDateString() {
		String dateString = getDay() + "/" + getMonth() + "/" + getYear();
		return dateString;
	}

	/**
	 * Gets the day of the date object in CustomDate
	 *
	 * @return
	 */
	public int getDay() {
		Calendar cal = createCal();
		int day = cal.get(Calendar.DAY_OF_MONTH);
		return day;
	}

	/**
	 * Gets the month of the date object in CustomDate
	 *
	 * @return
	 */
	public int getMonth() {
		Calendar cal = createCal();
		int month = cal.get(Calendar.MONTH) + 1;
		return month;
	}

	/**
	 * Gets the time of the date object in CustomDate
	 *
	 * @return
	 */
	public int getTime() {
		Calendar cal = createCal();
		return cal.get(Calendar.HOUR_OF_DAY) * 100 + cal.get(Calendar.MINUTE);
	}

	/**
	 * Gets the year of the date object in CustomDate
	 *
	 * @return
	 */
	public int getYear() {
		Calendar cal = createCal();
		int year = cal.get(Calendar.YEAR);
		return year;
	}

	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + ((date == null) ? 0 : date.hashCode());
		return result;
	}

	/**
	 * Empty command for storage compatibility purposes
	 *
	 * @param dateString
	 */
	public void setDateString(String dateString) {
	}

	/**
	 * Set day of the customdate using the value
	 *
	 * @param field
	 * @param val
	 */
	public void setDay(int day) {
		Calendar cal = createCal();
		cal.set(Calendar.DAY_OF_MONTH, day);
		this.date = cal.getTime();
	}

	/**
	 * Set month of the customdate using the value
	 *
	 * @param field
	 * @param val
	 */
	public void setMonth(int month) {
		Calendar cal = createCal();
		cal.set(Calendar.MONTH, month - 1);
		this.date = cal.getTime();
	}

	/**
	 * Set a time of the customdate using the value
	 *
	 * @param field
	 * @param val
	 */
	public void setTime(int time) {
		Calendar cal = createCal();
		cal.set(Calendar.HOUR_OF_DAY, time / 100);
		cal.set(Calendar.MINUTE, time % 100);
		cal.set(Calendar.SECOND, 0);
		this.date = cal.getTime();
	}

	/**
	 * Set year of the CustomDate using the value
	 *
	 * @param field
	 * @param val
	 */
	public void setYear(int year) {
		Calendar cal = createCal();
		cal.set(Calendar.YEAR, year);
		this.date = cal.getTime();
	}

	@Override
	public String toString() {
		Calendar cal = createCal();
		String day = dayArray[cal.get(Calendar.DAY_OF_WEEK) - 1];
		String month = monthArray[getMonth() - 1];
		int time = getTime();
		int hour = time / 100 - 12 < 0 ? time / 100 : time / 100 - 12;
		hour = (hour == 0) ? 12 : hour;
		String timeString = String.format("%d.%02d", hour, time % 100);
		if (time / 100 - 12 < 0) {
			timeString += " am";
		} else {
			timeString += " pm";
		}
		return String.format(DATE_FORMAT, timeString, getDay(), month,
				getYear(), day);
	}
}
```
###### parser\AddParser.java
``` java
 */
public class AddParser extends ArgsParserAbstract {

	/** Messaging */
	private static final String MESSAGE_INVALID_FORMAT = "Use format: add <title> by <date> <time>";
	private static final String MESSAGE_INVALID_TITLE = "Title";
	private static final String MESSAGE_INVALID_DATETIME = "Date/Time";

	/** Command parameters **/
	private String title;
	private CustomDate dueDate;
	private int endTime;
	private boolean isFloat;

	/**
	 * Constructor for AddParser objects. Checks if arguments are valid and
	 * stores the correct arguments properly. Throws the appropriate exception
	 * if arguments are invalid. Contains methods to add a task to storage.
	 * 
	 * @param args
	 * @throws Exception
	 */
	public AddParser(String args) throws Exception {
		super(args);
		this.argsArray = splitArgs("\\sby\\s", -1);
		removeEscapeCharacters();
		this.count = argsArray.size();
		splitArgsAfterDateTime();
		this.count = argsArray.size();
		this.isFloat = false;

		for (int i = 0; i < count; i++) {
			assertNotNull(argsArray.get(i));
		}

		if (validNumArgs()) {
			if (count == 1) {
				setFloatParams();
			} else {
				setProperParams();
			}

			checkTitle();
			checkDateTime();
			errorInvalidArgs();
		} else {
			errorInvalidFormat(MESSAGE_INVALID_FORMAT);
		}
	}

	/**
	 * Replaces characters that were used for escaping the keyword argument that
	 * was used for splitting
	 */
	private void removeEscapeCharacters() {
		for (int i = 0; i < argsArray.size(); i++) {
			argsArray.set(
					i,
					argsArray.get(i).trim()
							.replaceAll("(?<=by)\"|\"(?=by)", STRING_EMPTY));
		}
	}

	/**
	 * Date/time argument might be concatenated with other arguments, thus the
	 * method splits the arguments properly
	 */
	private void splitArgsAfterDateTime() {
		if (argsArray.size() > 1 && argsArray.get(count - 1).contains(" ")) {
			while (true) {
				String last = getLastWord(argsArray.get(count - 1));
				if (getDate(last) != null) {
					break;
				} else {
					splitOnce(last);
				}
			}
		}
	}

	/**
	 * Gives last word of a string
	 * 
	 * @param string
	 * @return String last word
	 */
	private String getLastWord(String string) {
		return string.split("\\s(?=\\S+$)")[1];
	}

	/**
	 * Adds last word to the argsArray and removes it from the date/time
	 * argument
	 * 
	 * @param last
	 */
	private void splitOnce(String last) {
		argsArray.add(count, last);
		argsArray.set(count - 1, removeLastWord(argsArray.get(count - 1)));
	}

	/**
	 * Removes last word from a string
	 * 
	 * @param string
	 * @return String with last word removed
	 */
	private String removeLastWord(String string) {
		return string.split("\\s(?=\\S+$)")[0];
	}

	/**
	 * Set the relevant parameters of AddCommand to that of a floating task
	 */
	private void setFloatParams() {
		this.title = getTitle(argsArray.get(0).trim());
		this.dueDate = null;
		this.endTime = -1;
		this.isFloat = true;
	}

	/**
	 * Set the relevant parameters of AddCommand to that of the specified task
	 */
	void setProperParams() {
		this.title = getTitle(argsArray.get(0).trim());
		this.dueDate = getDate(argsArray.get(1).trim());
		this.endTime = dueDate == null ? -1 : dueDate.getTime();
		assertFalse(isFloat);
	}

	/**
	 * Adds error message if title is invalid
	 */
	private void checkTitle() {
		if (title == null) {
			invalidArgs.add(MESSAGE_INVALID_TITLE);
		}
	}

	/**
	 * Adds error message if invalid date and time specified, and task to be
	 * added is not a floating task
	 */
	private void checkDateTime() {
		if (this.dueDate == null && !isFloat) {
			invalidArgs.add(MESSAGE_INVALID_DATETIME);
		}
	}

	@Override
	boolean validNumArgs() {
		if (this.count > 2) {
			return false;
		} else {
			return true;
		}
	}

	/**
	 * Returns an AddCommand object with the proper parameters
	 * 
	 * @return
	 * @throws Exception
	 */
	Command getCommand() throws Exception {
		Command add = new AddCommand(this.title, this.dueDate, this.endTime);
		assertNotNull(add);
		return add;
	}
}
```
###### parser\AddParserTest.java
``` java
 */
public class AddParserTest {

	private static final String MESSAGE_INVALID_FORMAT = "Use format: add <title> by <date> <time>";
	private static final String MESSAGE_INVALID_TITLE = "[Title]";
	private static final String MESSAGE_INVALID_DATETIME = "[Date/Time]";
	private static final String MESSAGE_TASK_ADDED = "Task added";
	private static final String MESSAGE_TASK_CLASH = ". Another task exists on the same date.";
	private static final String MESSAGE_TASK_ERROR = "Unable to add task";
	private static final String MESSAGE_HEADER_INVALID = "Invalid arguments: %s";

	@Test
	public void testNormalInputs() throws Exception {
		ArgsParserAbstract task = new AddParser("testTask by 9-10-2015 at 2359");
		ArgsParserAbstract floatTask = new AddParser("testFloat");
		ArgsParserAbstract flexiTask1 = new AddParser(
				"testFlexi by 1st January at 12pm");
		ArgsParserAbstract flexiTask2 = new AddParser(
				"testFlexi by 21-12-15 at 1234");
		ArgsParserAbstract flexiDateOnly = new AddParser(
				"testFlexi by 21-12-15");
		ArgsParserAbstract flexiTimeOnly = new AddParser("testFlexi at 1234");
		ArgsParserAbstract reverseDateTime = new AddParser(
				"testFlexi at 12pm by 1st January");
	}

	@Test
	public void testWrongNumArgs() {
		final String MESSAGE_ERROR = String.format(MESSAGE_HEADER_INVALID,
				MESSAGE_INVALID_DATETIME);
		try {
			AddParser moreArgs = new AddParser(
					"testTask by 9-10-2015 at 0000 weekly");
			fail();
		} catch (Exception e) {
			assertEquals(MESSAGE_INVALID_FORMAT, e.getMessage());
		}

		try {
			AddParser timeMoreArgs = new AddParser(
					"testFlexi by 1st January at 12pm at 2pm");
			fail();
		} catch (Exception e) {
			assertEquals(MESSAGE_ERROR, e.getMessage());
		}

		try {
			AddParser dateMoreArgs = new AddParser(
					"testFlexi by 1st January by 2nd January at 2359");
			fail();
		} catch (Exception e) {
			assertEquals(MESSAGE_INVALID_FORMAT, e.getMessage());
		}
	}

	@Test
	public void testWrongTitle() {
		final String MESSAGE_ERROR = String.format(MESSAGE_HEADER_INVALID,
				MESSAGE_INVALID_TITLE);
		try {
			AddParser noTitle = new AddParser("");
			fail();
		} catch (Exception e) {
			assertEquals(MESSAGE_ERROR, e.getMessage());
		}
	}

	@Test
	public void testWrongDate() throws Exception {
		final String MESSAGE_ERROR = String.format(MESSAGE_HEADER_INVALID,
				MESSAGE_INVALID_DATETIME);

		try {
			AddParser impossibleDate = new AddParser(
					"testTask by 99-10-2015 at 2359");
			fail();
		} catch (Exception e) {
			assertEquals(MESSAGE_ERROR, e.getMessage());
		}

		try {
			AddParser lettersInDate = new AddParser(
					"testTask by 9-10-2015a at 2359");
			fail();
		} catch (Exception e) {
			assertEquals(String.format(MESSAGE_ERROR, "9-10-2015a"),
					e.getMessage());
		}
		try {
			AddParser wrongTime = new AddParser("testTask by 25a78");
			fail();
		} catch (Exception e) {
			assertEquals(MESSAGE_ERROR, e.getMessage());
		}
	}
}
```
###### parser\ArgsParserAbstract.java
``` java
 */
public abstract class ArgsParserAbstract {

	/** Checking */
	protected static final String STRING_EMPTY = "";
	protected static final CustomDate today = new CustomDate(Chronic
			.parse("today 00:00").getEndCalendar().getTime());

	/** Messaging */
	protected static final String MESSAGE_HEADER_INVALID = "Invalid arguments: %s";
	protected TreeSet<String> invalidArgs = new TreeSet<String>();
	protected String returnMsg = STRING_EMPTY;

	/** Main variables */
	protected String args;
	protected ArrayList<String> argsArray;
	protected int count;

	/**
	 * Constructor for Parser objects. Stores the arguments passed in when the
	 * constructor is called.
	 * 
	 * @param args
	 */
	public ArgsParserAbstract(String args) {
		assertNotNull(args);
		this.args = args;
	}

	/**
	 * Adds the time as default to a given string if no time has been specified
	 * in the string originally. Parses the string into a CustomDate object
	 * using jChronic natural date parser. Returns null if date string cannot be
	 * parsed.
	 * 
	 * @param date
	 * @return CustomDate objects with given date and time, default time if not
	 *         specified
	 */
	private CustomDate dateWithTime(String date, String time) {
		assertNotNull(date);
		Span span;
		if (Chronic.parse(date) != null) {
			if ((span = Chronic.parse(date + " " + time)) != null) {
				return new CustomDate(span.getBeginCalendar().getTime());
			} else {
				span = Chronic.parse(date);
				return new CustomDate(span.getBeginCalendar().getTime());
			}
		} else {
			return null;
		}
	}

	/**
	 * Checks if a given string has date in the format dd/MM or dd-MM and adds
	 * the current year onto the string, for correct parsing. Does nothing if
	 * year is already present in string.
	 * 
	 * @param date
	 * @return String with year
	 */
	private String dateWithYear(String date) {
		assertNotNull(date);
		Matcher m = getMatcher(date,
				"(?<=\\s{0,1})\\d{1,2}(/|-)\\d{1,2}(?=\\s{0,1}!(/|-|\\d))");
		assertNotNull(m);

		if (m.find()) {
			String s = m.group(0);
			assertNotNull(s);

			String temp = addCurrentYear(date, s);
			assertNotNull(getDate(temp));

			if (getDate(temp).compareTo(today) == -1) {
				date = addNextYear(date, s);
				assertNotNull(getDate(date));
			} else {
				date = temp;
			}

		}
		return date;
	}

	/**
	 * Add current year to date string, behind a specific dateformat
	 * 
	 * @param date
	 * @param s
	 * @return
	 */
	String addCurrentYear(String date, String s) {
		date = date.replaceAll(s, s + "/" + new CustomDate().getYear());
		return date;
	}

	/**
	 * Add next year to date string, behind a specific dateformat
	 * 
	 * @param date
	 * @param s
	 * @param temp
	 * @return
	 */
	String addNextYear(String date, String s) {
		date = date.replaceAll(s, s + "/" + (new CustomDate().getYear() + 1));
		return date;
	}

	/**
	 * Throws exception if error messages for invalid arguments are present
	 * 
	 * @throws IllegalArgumentException
	 */
	protected void errorInvalidArgs() throws IllegalArgumentException {
		if (invalidArgs.size() > 0) {
			throw new IllegalArgumentException(String.format(
					MESSAGE_HEADER_INVALID, invalidArgs));
		}
	}

	/**
	 * Throws exception if error messages for format are present
	 * 
	 * @throws IllegalArgumentException
	 */
	protected void errorInvalidFormat(String msg)
			throws IllegalArgumentException {
		throw new IllegalArgumentException(msg);
	}

	/**
	 * Formats the time in a given string properly for parsing, if present.
	 * 
	 * @param date
	 * @return String with correct time format
	 */
	private String formatCorrectTime(String date) {
		assertNotNull(date);
		Matcher m = getMatcher(date,
				"(?<=\\s{0,1})(?<![A-z]\\s|/|-)\\d{4}(?=\\s{0,1}!\\d+(am|pm)!\\d{4})");
		assertNotNull(m);

		if (m.find()) {
			String s = m.group(0);
			assertNotNull(s);
			date = date.replaceAll(s,
					s.substring(0, 2) + ":" + s.substring(2, s.length()));
		}
		date = date.replaceAll("(?<=[0-9]+)\\.(?=[0-9])+", ":");
		return date;
	}

	/**
	 * Ensure that all correct input are properly formatted for the jChronic
	 * parser
	 * 
	 * @param date
	 * @return
	 */
	String formatDate(String date) {
		date = date.trim();
		// System.out.println("Date 1: " + date);
		date = formatCorrectTime(date);
		// System.out.println("Date 2: " + date);
		date = dateWithYear(date);
		// System.out.println("Date 3: " + date);
		date = swapDayMonth(date);
		// System.out.println("Date 4: " + date);
		date = placeTimeBehind(date);
		// System.out.println("Date 5: " + date);
		date = swapDayMonthFlexi(date);
		// System.out.println("Date 6: " + date);
		return date;
	}

	/**
	 * Moves time parameter from front of the date string to back
	 * 
	 * @param date
	 * @return
	 */
	private String placeTimeBehind(String date) {
		ArrayList<String> temp = new ArrayList<String>(Arrays.asList(date
				.split(" ")));
		if (temp.get(0).contains(":") || temp.get(0).contains("am")
				|| temp.get(0).contains("pm")) {
			temp.add(temp.get(0));
			temp.remove(0);
			date = "";
			for (String s : temp) {
				date += s + " ";
			}
			date = date.trim();
		}
		return date;
	}

	/**
	 * Checks if a given string contains a valid date and/or time and parses it
	 * into a CustomDate object, or null if the string is invalid. Uses default
	 * values if a date field or time is not given. Default date is current day,
	 * current month, current year. Default time is 2359.
	 * 
	 * @param date
	 * @return CustomDate object with valid date and time
	 */
	protected CustomDate getDate(String date) {
		assertNotNull(date);
		date = formatDate(date);
		return dateWithTime(date, "23:59");
	}

	/**
	 * A variation on getDate with default time 0000
	 * 
	 * @param date
	 * @return CustomDate object with valid date and time
	 */
	protected CustomDate getDateTimeZero(String date) {
		assertNotNull(date);
		date = formatDate(date);
		return dateWithTime(date, "00:00");
	}

	/**
	 * Get both item type and item index using the itemID and return the
	 * corresponding item. Checks the validity of item type. Returns null if the
	 * itemID is invalid or item does not exist.
	 * 
	 * @param itemID
	 * @return Task object corresponding
	 */
	protected Item getItemByID(String itemID) {
		assertNotNull(itemID);
		String type = getItemIdType(itemID);
		Integer index = getItemIdIndex(itemID);
		try {
			if (index != -1) {
				switch (type) {
				case "t":
					return GUIModel.taskList.get(index);
				case "d":
					return GUIModel.taskDoneList.get(index);
				case "e":
					return GUIModel.eventList.get(index);
				case "p":
					return GUIModel.eventDoneList.get(index);
				default:
					return null;
				}
			} else {
				return null;
			}
		} catch (Exception e) {
			return null;
		}
	}

	/**
	 * Gets the index from the itemID and returns it as a number. Returns -1 if
	 * the index is not a valid number.
	 * 
	 * @param itemID
	 * @return int index of the item
	 */
	private int getItemIdIndex(String itemID) {
		assertNotNull(itemID);
		try {
			return Integer.parseInt(itemID.substring(1)) - 1;
		} catch (Exception e) {
			return -1;
		}
	}

	/**
	 * Gets the item type from the itemID. Does not check for validity of type.
	 * 
	 * @param itemID
	 * @return String item type
	 */
	private String getItemIdType(String itemID) {
		assertNotNull(itemID);
		if (itemID.isEmpty()) {
			return null;
		}
		return itemID.substring(0, 1).toLowerCase();
	}

	/**
	 * Creates a matcher using a pattern object with the given regex
	 * 
	 * @param date
	 * @param regex
	 * @return Matcher object with given regex
	 */
	private Matcher getMatcher(String date, String regex) {
		Pattern p = Pattern.compile(regex);
		assertNotNull(p);
		Matcher m = p.matcher(date);
		return m;
	}

	/**
	 * Checks if priority is valid and returns it as integer, or -1 if invalid
	 * priority
	 * 
	 * @param priority
	 * @return String priority
	 */
	protected String getPriority(String priority) {
		assertNotNull(priority);
		if (priority.equals("high") || priority.equals("medium")
				|| priority.equals("low") || priority.equals("")) {
			return priority;
		}
		return null;
	}

	/**
	 * Checks if the title is empty and returns null or the title
	 * 
	 * @param title
	 * @return String title
	 */
	protected String getTitle(String title) {
		assertNotNull(title);
		if (title.equals(STRING_EMPTY)) {
			return null;
		}
		return title;
	}

	/**
	 * Get the token for a date string
	 * 
	 * @param s
	 * @return
	 */
	private String getToken(String s) {
		assert (s.contains("/") | s.contains("-"));
		if (s.contains("/")) {
			return "/";
		} else {
			return "-";
		}
	}

	/**
	 * Set the relevant arguments provided to corresponding command parameters
	 */
	abstract void setProperParams();

	/**
	 * Create an ArrayList of Strings that is split into arguments according to
	 * the regex and into maximum number of elements specified in the limit.
	 * 
	 * @param args
	 * @param regex
	 * @param limit
	 * @return ArrayList of args
	 */
	protected ArrayList<String> splitArgs(String regex, int limit) {
		args = args.replaceAll("\\s+", " ");
		return new ArrayList<String>(Arrays.asList(args.split(regex, limit)));
	}

	/**
	 * Swaps the day and the month for non-flexi in order to parse properly
	 * 
	 * @param date
	 * @return
	 */
	private String swapDayMonth(String date) {
		Matcher m = getMatcher(date,
				"(?<=\\s{0,1})\\d{1,2}(/|-)\\d{1,2}(?=\\s{0,1}|/)");
		if (m.find()) {
			date = swapAroundToken(date, m);
		}
		return date;
	}

	/**
	 * Swaps the given day and month around the date token "-" or "/"
	 * 
	 * @param date
	 * @param m
	 * @return
	 */
	String swapAroundToken(String date, Matcher m) {
		String s = m.group(0);
		String token = getToken(s);
		String[] splitS = s.split(token, 2);
		String newS = splitS[1] + token + splitS[0];
		date = date.replace(s, newS);
		return date;
	}

	/**
	 * Swaps the day and the month for flexicommands in order to parse properly
	 * 
	 * @param date
	 * @return
	 */
	private String swapDayMonthFlexi(String date) {
		Matcher m = getMatcher(date,
				"(?<=\\s{0,1})\\d{1,2}(|st|nd|rd|th)\\s[A-z]{3,}(?=\\s{0,1})");
		if (m.find()) {
			String s = m.group(0);
			String[] splitS = s.split(" ", 2);
			String newS = splitS[1] + " " + splitS[0];
			date = date.replace(s, newS);
		}
		return date;
	}

	/**
	 * Checks if the correct number of arguments are provided for the given
	 * command
	 * 
	 * @return boolean true/false
	 */
	abstract boolean validNumArgs();

	/**
	 * Returns the Command object corresponding to the user command for proper
	 * execution
	 * 
	 * @return
	 * @throws Exception
	 */
	abstract Command getCommand() throws Exception;
}
```
###### parser\DateParser.java
``` java
 */
public class DateParser extends ArgsParserAbstract {

	/** Messaging **/
	private static final String MESSAGE_INVALID_FORMAT = "Use Format: date <start date> to <end date>";
	private static final String MESSAGE_INVALID_DATETIME_END = "End date/time";
	private static final String MESSAGE_INVALID_DATETIME_START = "Start date/time";
	private static final String MESSAGE_INVALID_DATETIME_RANGE = "End date/time is earlier than Start date/time";

	/** Command parameters **/
	private CustomDate dateStart;
	private CustomDate dateEnd;

	/**
	 * Constructor for DateParser objects. Checks if arguments are valid and
	 * stores the correct arguments properly. Throws the appropriate exception
	 * if arguments are invalid. Contains methods to display the date within the
	 * time range.
	 * 
	 * @param args
	 * @throws Exception
	 */
	public DateParser(String args) throws Exception {
		super(args);
		this.argsArray = splitArgs("\\sto\\s", -1);
		this.count = argsArray.size();

		if (validNumArgs()) {
			setProperParams();
			checkDateTime(dateStart, 0);
			checkDateTime(dateEnd, 1);
			checkDateRange();
			errorInvalidArgs();
		} else {
			errorInvalidFormat(MESSAGE_INVALID_FORMAT);
		}
	}

	/**
	 * Adds error message if invalid date and time specified, according to if
	 * the date is the start or end date.
	 */
	private void checkDateTime(CustomDate date, int type) {
		assert (type == 0 || type == 1);
		if (date == null) {
			if (type == 0) {
				invalidArgs.add(MESSAGE_INVALID_DATETIME_START);
			} else {
				invalidArgs.add(MESSAGE_INVALID_DATETIME_END);
			}
		}
	}

	/**
	 * Adds error message if end date is before start date
	 */
	void checkDateRange() {
		if (dateStart != null && dateEnd != null && !validDateRange()) {
			invalidArgs.add(MESSAGE_INVALID_DATETIME_RANGE);
		}
	}

	/**
	 * Check if the end date given is after the start date
	 * 
	 * @return
	 */
	public boolean validDateRange() {
		return dateEnd.compareTo(dateStart) > 0;
	}

	@Override
	void setProperParams() {
		String start = argsArray.get(0).trim();
		String end = count == 2 ? argsArray.get(1).trim() : STRING_EMPTY;

		dateStart = start.equals(STRING_EMPTY) ? new CustomDate(new Date(0))
				: getDateTimeZero(start);
		dateEnd = end.equals(STRING_EMPTY) ? new CustomDate(new Date(
				Long.MAX_VALUE)) : getDate(end);
	}

	@Override
	boolean validNumArgs() {
		if (this.count > 2) {
			return false;
		} else {
			return true;
		}
	}

	@Override
	Command getCommand() {
		Command date = new DateCommand(this.dateStart, this.dateEnd);
		assertNotNull(date);
		return date;
	}
}
```
###### parser\DelParser.java
``` java
 */
public class DelParser extends ArgsParserAbstract {

	/** Messaging **/
	private static final String MESSAGE_INVALID_FORMAT = "Use Format: delete <item_id>";
	private static final String MESSAGE_INVALID_ITEM_ID = "item_id";

	/** Command Parameters **/
	private Item item;
	private String itemID;

	/**
	 * Constructor for DelParser objects. Checks if arguments are valid and
	 * stores the correct arguments properly. Throws the appropriate exception
	 * if arguments are invalid. Contains methods to remove to item.
	 * 
	 * @param args
	 * @throws Exception
	 */
	public DelParser(String args) throws Exception {
		super(args);
		this.argsArray = splitArgs(" ", -1);
		this.count = argsArray.size();

		if (validNumArgs()) {
			setProperParams();
			checkItemExists();
			errorInvalidArgs();
		} else {
			errorInvalidFormat(MESSAGE_INVALID_FORMAT);
		}
	}

	/**
	 * Adds error message if item does not exist or unable to get
	 */
	void checkItemExists() {
		if (item == null) {
			invalidArgs.add(MESSAGE_INVALID_ITEM_ID);
		}
	}

	void setProperParams() {
		itemID = argsArray.get(0).trim();
		item = getItemByID(itemID);
	}

	boolean validNumArgs() {
		if (this.count != 1) {
			return false;
		} else {
			return true;
		}
	}

	@Override
	Command getCommand() throws Exception {
		Command del = new DelCommand(this.itemID, this.item);
		return del;
	}

}
```
###### parser\DoneParser.java
``` java
 */
public class DoneParser extends ArgsParserAbstract {

	/** Messaging **/
	private static final String MESSAGE_INVALID_FORMAT = "Use Format: done <item_id>";
	private static final String MESSAGE_INVALID_ITEM_ID = "item_id";
	private static final String MESSAGE_INVALID_DONE = "%s is already done!";

	/** Command Parameters **/
	private Item item;
	private String itemID;

	/**
	 * Constructor for DoneParser objects. Checks if arguments are valid and
	 * stores the correct arguments properly. Throws the appropriate exception
	 * if arguments are invalid. Contains methods to move item to done list.
	 * 
	 * @param args
	 * @throws Exception
	 */
	public DoneParser(String args) throws Exception {
		super(args);
		this.argsArray = splitArgs(" ", -1);
		this.count = argsArray.size();

		if (validNumArgs()) {
			setProperParams();
			checkItemDone();
			errorInvalidArgs();
		} else {
			errorInvalidFormat(MESSAGE_INVALID_FORMAT);
		}
	}

	/**
	 * Adds error message if item does not exist or unable to get or is already
	 * done
	 */
	void checkItemDone() {
		if (item == null) {
			invalidArgs.add(MESSAGE_INVALID_ITEM_ID);
		} else if (argsArray.get(0).trim().contains("d")
				|| argsArray.get(0).trim().contains("p")) {
			invalidArgs.add(String.format(MESSAGE_INVALID_DONE, itemID));
		}
	}

	@Override
	void setProperParams() {
		itemID = argsArray.get(0).trim();
		item = getItemByID(itemID);
	}

	@Override
	boolean validNumArgs() {
		if (this.count != 1) {
			return false;
		} else {
			return true;
		}
	}

	@Override
	Command getCommand() throws Exception {
		Command done = new DoneCommand(this.itemID, this.item);
		return done;
	}

}
```
###### parser\EditParser.java
``` java
 */
public class EditParser extends ArgsParserAbstract {

	/** Messaging **/
	private static final String MESSAGE_INVALID_FORMAT = "Use format: edit <item_id> <field> <value>";
	private static final String MESSAGE_INVALID_FIELD = "Unknown field";
	private static final String MESSAGE_INVALID_TASK_START_TIME = "Task cannot have start time";
	private static final String MESSAGE_INVALID_TASK_START_DATE = "Task cannot have start date";
	private static final String MESSAGE_INVALID_DATE_START = "Start date";
	private static final String MESSAGE_INVALID_DATE_END = "End date";
	private static final String MESSAGE_INVALID_TIME_START = "Start time";
	private static final String MESSAGE_INVALID_TIME_END = "End time";
	private static final String MESSAGE_INVALID_ITEM_ID = "item_id";
	private static final String MESSAGE_INVALID_TITLE = "Title";

	/** For checking **/
	private static final String FIELD_TIME_END = "end time";
	private static final String FIELD_TIME_START = "start time";
	private static final String FIELD_TIME = "time";
	private static final String FIELD_DATE_START = "start date";
	private static final String FIELD_DATE_END = "end date";
	private static final String FIELD_DATE = "date";
	private static final String FIELD_TITLE = "title";
	private static final int START = 0;
	private static final int END = 1;

	/** Command parameters **/
	private String field;
	private String value;
	private String itemID;
	private Item item;
	private boolean isTask;
	private Object editObject;

	/**
	 * Constructor for EditParser objects. Checks if arguments are valid and
	 * stores the correct arguments properly. Throws the appropriate exception
	 * if arguments are invalid. Contains methods to update the item in storage.
	 * 
	 * @param args
	 * @throws Exception
	 */
	public EditParser(String args) throws Exception {
		super(args);

		// For empty sting value when only 2 args are provided
		args = args + " ";

		this.argsArray = splitArgs("(?<!end|start)\\s", 3);

		this.count = argsArray.size();

		if (validNumArgs()) {
			setProperParams();

			checkItemExists();

			errorInvalidArgs();

			isTask = item.getType().equals("task");

			switch (field.toLowerCase()) {
			case FIELD_TITLE:
				checkTitle();
				break;
			case FIELD_DATE_START:
				checkDate(START);
				break;
			case FIELD_DATE_END:
				checkDate(END);
				break;
			case FIELD_DATE:
				checkDate(END);
				break;
			case FIELD_TIME_START:
				checkTime(START);
				break;
			case FIELD_TIME_END:
				checkTime(END);
				break;
			case FIELD_TIME:
				checkTime(END);
				break;
			default:
				invalidField();
			}
			errorInvalidArgs();
		} else {
			errorInvalidFormat(MESSAGE_INVALID_FORMAT);
		}
	}

	/**
	 * Adds error message if item does not exist or unable to get
	 */
	void checkItemExists() {
		if (item == null) {
			invalidArgs.add(MESSAGE_INVALID_ITEM_ID);
		}
	}

	/**
	 * Adds error message if title is invalid
	 */
	void checkTitle() {
		if ((editObject = getTitle(value)) == null) {
			invalidArgs.add(MESSAGE_INVALID_TITLE);
		}
	}

	/**
	 * Adds error message if date is invalid or if task is to be made floating,
	 * sets toFloat to true.
	 */
	void checkDate(int type) {
		assert (type == START || type == END);
		if (isTask && type == START) {
			invalidArgs.add(MESSAGE_INVALID_TASK_START_DATE);
		} else {
			if (value.equals(STRING_EMPTY) && isTask) {
			} else if ((editObject = getDate(value)) == null) {
				addInvalidDateType(type);
			}
		}
	}

	/**
	 * Adds the proper invalid date message to error message
	 * 
	 * @param type
	 */
	void addInvalidDateType(int type) {
		if (type == START) {
			invalidArgs.add(MESSAGE_INVALID_DATE_START);
		} else {
			invalidArgs.add(MESSAGE_INVALID_DATE_END);
		}
	}

	/**
	 * Adds error message if time is invalid, according to type, or error
	 * message if the start time is provided for tasks, or get the correct time
	 * if valid.
	 */
	void checkTime(int type) {
		assert (type == START || type == END);
		if (isTask && type == START) {
			invalidArgs.add(MESSAGE_INVALID_TASK_START_TIME);
		} else {
			if ((editObject = getDate(value)) == null) {
				addInvalidTimeType(type);
			} else {
				editObject = getDate(value).getTime();
			}
		}
	}

	/**
	 * Adds the proper invalid time message to error message
	 * 
	 * @param type
	 */
	void addInvalidTimeType(int type) {
		if (type == START) {
			invalidArgs.add(MESSAGE_INVALID_TIME_START);
		} else {
			invalidArgs.add(MESSAGE_INVALID_TIME_END);
		}
	}

	/**
	 * Adds invalid field message to error messages
	 */
	void invalidField() {
		invalidArgs.add(MESSAGE_INVALID_FIELD);
	}

	/**
	 * Set the relevant parameters of EditCommand to that of the specified task
	 */
	@Override
	void setProperParams() {
		this.itemID = argsArray.get(0).trim();
		this.item = getItemByID(itemID);
		this.field = argsArray.get(1).trim();
		this.value = argsArray.get(2).trim();
	}

	@Override
	boolean validNumArgs() {
		if (this.count != 3) {
			return false;
		} else {
			return true;
		}
	}

	@Override
	Command getCommand() throws Exception {
		Command edit = new EditCommand(field, editObject, itemID, item, isTask);
		return edit;
	}
}
```
###### parser\EventParser.java
``` java
 */
public class EventParser extends ArgsParserAbstract {

	/** Messaging **/
	private static final String MESSAGE_INVALID_FORMAT = "Use format: event <title> "
			+ "from <start date> <start time> " + "to <end date> <end time>";
	private static final String MESSAGE_INVALID_DATETIME_END = "End date/time";
	private static final String MESSAGE_INVALID_DATETIME_START = "Start date/time";
	private static final String MESSAGE_INVALID_DATETIME_RANGE = "End date/time is earlier than Start date/time";
	private static final String MESSAGE_INVALID_TITLE = "Title";

	/** For checking **/
	private static final int START = 0;
	private static final int END = 1;

	/** Command parameters **/
	protected String title;
	protected CustomDate dateStart;
	protected CustomDate dateEnd;
	protected int startTime;
	protected int endTime;

	/**
	 * Constructor for EventParser objects. Checks if arguments are valid and
	 * stores the correct arguments properly. Throws the appropriate exception
	 * if arguments are invalid. Contains methods to add an event to storage.
	 * 
	 * @param args
	 * @throws Exception
	 */
	public EventParser(String args) throws Exception {
		super(args);
		this.argsArray = splitArgs("\\sto\\s|\\sfrom\\s", -1);
		removeEscapeCharacters();
		System.out.println(argsArray);
		this.count = argsArray.size();
		splitArgsAfterDateTime();
		this.count = argsArray.size();

		for (int i = 0; i < count; i++) {
			assertNotNull(argsArray.get(i));
		}

		if (validNumArgs()) {

			setProperParams();

			setDefaultEndDay();

			checkTitle();

			checkDateTime(dateStart, START);
			checkDateTime(dateEnd, END);

			checkDateRange();

			errorInvalidArgs();
		} else {
			errorInvalidFormat(MESSAGE_INVALID_FORMAT);
		}
	}

	/**
	 * Replaces characters that were used for escaping the keyword argument that
	 * was used for splitting
	 */
	private void removeEscapeCharacters() {
		for (int i = 0; i < argsArray.size(); i++) {
			argsArray
					.set(i,
							argsArray
									.get(i)
									.trim()
									.replaceAll(
											"(?<=from)\"|\"(?=from)|(?<=to)\"|\"(?=to)",
											STRING_EMPTY));
		}
	}

	/**
	 * Date/time argument might be concatenated with other arguments, thus the
	 * method splits the arguments properly
	 */
	private void splitArgsAfterDateTime() {
		if (argsArray.size() > 1 && argsArray.get(count - 1).contains(" ")) {
			while (true) {
				String last = getLastWord(argsArray.get(count - 1));
				if (getDate(last) != null) {
					break;
				} else if (!last.matches(".*\\d+.*")) {
					splitOnce(last);
				} else {
					break;
				}
			}
		}
	}

	/**
	 * Gives last word of a string
	 * 
	 * @param string
	 * @return String last word
	 */
	private String getLastWord(String string) {
		return string.split("\\s(?=\\S+$)")[1];
	}

	/**
	 * Adds last word to the argsArray and removes it from the date/time
	 * argument
	 * 
	 * @param last
	 */
	private void splitOnce(String last) {
		argsArray.add(count, last);
		argsArray.set(count - 1, removeLastWord(argsArray.get(count - 1)));
	}

	/**
	 * Removes last word from a string
	 * 
	 * @param string
	 * @return String with last word removed
	 */
	private String removeLastWord(String string) {
		return string.split("\\s(?=\\S+$)")[0];
	}

	void setProperParams() {
		this.title = getTitle(argsArray.get(0).trim());
		this.dateStart = getDate(argsArray.get(1).trim());
		this.dateEnd = getDate(argsArray.get(2).trim());
		this.startTime = dateStart == null ? -1 : dateStart.getTime();
		this.endTime = dateEnd == null ? -1 : dateEnd.getTime();
	}

	/**
	 * Set the default day to be start day if unspecified
	 */
	private void setDefaultEndDay() {
		if (dateEnd != null) {
			if (dateEnd.getDateString().equals(today.getDateString())) {
				if (endIsTimeOnly()) {
					setEndFollowingStart();
				}
			}
		}
	}

	/**
	 * Check if only time was given for end date. Parsing with another date
	 * other than default would give a customDate object, else null if not only
	 * time was given.
	 * 
	 * @return
	 */
	private boolean endIsTimeOnly() {
		CustomDate temp = getDate("tomorrow " + argsArray.get(2).trim());
		return temp != null;
	}

	/**
	 * Set the date month and year according to that of the start day. Time may
	 * still be different
	 */
	private void setEndFollowingStart() {
		dateEnd.setDay(dateStart.getDay());
		dateEnd.setMonth(dateStart.getMonth());
		dateEnd.setYear(dateStart.getYear());
	}

	/**
	 * Adds error message if title is invalid
	 */
	private void checkTitle() {
		if (title == null) {
			invalidArgs.add(MESSAGE_INVALID_TITLE);
		}
	}

	/**
	 * Adds error message if invalid date and time specified, according to if
	 * the date is the start or end date.
	 */
	private void checkDateTime(CustomDate date, int type) {
		assert (type == START || type == END);
		if (date == null) {
			addInvalidDateTimeType(type);
		}
	}

	/**
	 * Adds the proper invalid message to error message
	 * 
	 * @param type
	 */
	private void addInvalidDateTimeType(int type) {
		if (type == START) {
			invalidArgs.add(MESSAGE_INVALID_DATETIME_START);
		} else {
			invalidArgs.add(MESSAGE_INVALID_DATETIME_END);
		}
	}

	/**
	 * Adds error message if end date is before start date
	 */
	private void checkDateRange() {
		if (dateStart != null && dateEnd != null && !validDateRange()) {
			invalidArgs.add(MESSAGE_INVALID_DATETIME_RANGE);
		}
	}

	/**
	 * Check if the end date given is after the start date
	 * 
	 * @return
	 */
	private boolean validDateRange() {
		return dateEnd.compareTo(dateStart) > 0;
	}

	boolean validNumArgs() {
		if (this.count != 3) {
			return false;
		} else {
			return true;
		}
	}

	@Override
	Command getCommand() throws Exception {
		Command event = new EventCommand(title, dateStart, dateEnd, startTime,
				endTime);
		return event;
	}
}
```
###### parser\Parser.java
``` java
 */
public class Parser {

	/** List of Command types */
	private static final String CMD_ADD = "add";
	private static final String CMD_DATE = "date";
	private static final String CMD_DELETE = "delete";
	private static final String CMD_DONE = "done";
	private static final String CMD_EDIT = "edit";
	private static final String CMD_EVENT = "event";
	private static final String CMD_EXIT = "exit";
	private static final String CMD_HELP = "help";
	private static final String CMD_PATH = "path";
	private static final String CMD_PRIORITY = "set";
	private static final String CMD_REDO = "redo";
	private static final String CMD_SEARCH = "search";
	private static final String CMD_SHOW = "show";
	private static final String CMD_SORT = "sort";
	private static final String CMD_TAG = "tag";
	private static final String CMD_UNDO = "undo";
	private static final String CMD_UNDONE = "undone";
	private static final String CMD_UNTAG = "untag";

	/** Error Messages */
	private static final String MESSAGE_INVALID_COMMAND = "Invalid command: %s";
	private static final String MESSAGE_INVALID_INPUT = "Please enter a command";

	/** Parser Instance **/
	private static Parser parser;

	/**
	 * Splits a given string of user input and returns the words after the first
	 * word of the input, which are the arguments of the command string
	 * 
	 * @param userInput
	 * @return String containing the arguments of the command string
	 */
	private static String getStringArgs(String userInput) {
		String[] toSplit = userInput.split(" ", 2);
		if (toSplit.length > 1) {
			return toSplit[1].trim();
		} else {
			return null;
		}
	}

	/**
	 * Splits a given string of user input and returns the first argument, which
	 * should be the command string
	 * 
	 * @param userInput
	 * @return String stating the command given by user
	 */
	private static String getStringCommand(String userInput) {
		String[] toSplit = userInput.split(" ", 2);
		return toSplit[0].toLowerCase().trim();
	}

	/**
	 * Checks if the command is valid and returns the correct Parser subclass of
	 * the user's command. Passes the arguments to an ArgsParserAbstract
	 * subclass, which will check the arguments' validity within its
	 * constructor. Exception thrown if a command string is not valid.
	 * 
	 * @param command
	 * @param args
	 * @return Command subclass object according to the user command
	 * @throws Exception
	 */
	private static ArgsParserAbstract inputValidation(String command,
			String args) throws Exception {
		args = args == null ? "" : args;
		switch (command) {
		case CMD_ADD:
			return new AddParser(args);
		case CMD_DATE:
			return new DateParser(args);
		case CMD_DELETE:
			return new DelParser(args);
		case CMD_DONE:
			return new DoneParser(args);
		case CMD_EDIT:
			return new EditParser(args);
		case CMD_EVENT:
			return new EventParser(args);
		case CMD_EXIT:
			return new DefaultParser(command);
		case CMD_HELP:
			return new DefaultParser(command);
		case CMD_PATH:
			return new PathParser(args);
		case CMD_PRIORITY:
			return new PriorityParser(args);
		case CMD_REDO:
			return new DefaultParser(command);
		case CMD_SEARCH:
			return new SearchParser(args);
		case CMD_SHOW:
			return new ShowParser(args);
		case CMD_SORT:
			return new SortParser(args);
		case CMD_TAG:
			return new TagParser(args);
		case CMD_UNDO:
			return new DefaultParser(command);
		case CMD_UNDONE:
			return new UndoneParser(args);
		case CMD_UNTAG:
			return new UntagParser(args);
		default:
			throw new Exception(String.format(MESSAGE_INVALID_COMMAND, command));
		}
	}

	/**
	 * Takes in an input from the user and splits into command and command
	 * arguments, before verifying them and returning the corresponding Command
	 * object. Exception is thrown if no input is given.
	 * 
	 * @param userInput
	 * @return Command object to use for executing
	 * @throws Exception
	 */
	public Command parse(String userInput) throws Exception {
		assertNotNull(userInput);
		if (!userInput.isEmpty()) {
			String trimInput = userInput.trim();

			String command = getStringCommand(trimInput);
			String args = getStringArgs(trimInput);

			return inputValidation(command, args).getCommand();
		} else {
			throw new Exception(MESSAGE_INVALID_INPUT);
		}
	}

	/**
	 * Creates an instance of Parser if it does not exist, otherwise, return the
	 * existing instantiated Parser.
	 * 
	 * @return
	 */
	public static Parser getInstance() {
		if (parser == null) {
			parser = new Parser();
		}
		return parser;
	}
}
```
###### parser\PathParser.java
``` java
 */
public class PathParser extends ArgsParserAbstract {

	/** Messaging **/
	private static final String MESSAGE_ARGUMENT_FORMAT = "Use Format: path <location>";
	/** Command parameters **/
	private String location;

	/**
	 * Constructor for PathParser objects. Checks if arguments are valid and
	 * stores the correct arguments properly. Throws the appropriate exception
	 * if arguments are invalid. Contains methods to change the file path
	 * location of storage textfile.
	 * 
	 * @param args
	 * @throws Exception
	 */
	public PathParser(String args) throws Exception {
		super(args);
		setProperParams();
		checkLocation();
	}

	/**
	 * Throw exception if no location was specified
	 * 
	 * @throws IllegalArgumentException
	 */
	void checkLocation() throws IllegalArgumentException {
		if (location.isEmpty()) {
			throw new IllegalArgumentException(MESSAGE_ARGUMENT_FORMAT);
		}
	}

	@Override
	void setProperParams() {
		this.location = args;
	}

	@Override
	boolean validNumArgs() {
		return true;
	}

	@Override
	Command getCommand() throws Exception {
		Command path = new PathCommand(this.location);
		return path;
	}
}
```
###### parser\PriorityParser.java
``` java
 */
public class PriorityParser extends ArgsParserAbstract {

	/** Messaging **/
	private static final String MESSAGE_ARGUMENT_FORMAT = "Use Format: set <item_id> <priority>";
	private static final String MESSAGE_INVALID_ITEM_ID = "item_id";
	private static final String MESSAGE_INVALID_PRIORITY = "Priority";

	/** Command parameters **/
	private Item item;
	private String itemID;
	private String priority;

	/**
	 * Constructor for PriorityParser objects. Checks if arguments are valid and
	 * stores the correct arguments properly. Throws the appropriate exception
	 * if arguments are invalid. Contains methods to change the priority of an
	 * item.
	 * 
	 * @param args
	 * @throws Exception
	 */
	public PriorityParser(String args) throws Exception {
		super(args);
		this.argsArray = splitArgs(" ", 2);
		this.count = argsArray.size();

		if (validNumArgs()) {
			setProperParams();
			checkItemExists();
			checkPriorityValid();
			errorInvalidArgs();
		} else {
			errorInvalidFormat(MESSAGE_ARGUMENT_FORMAT);
		}
	}

	/**
	 * Adds error message if item does not exist or unable to get
	 */
	void checkItemExists() {
		if (item == null) {
			invalidArgs.add(MESSAGE_INVALID_ITEM_ID);
		}
	}

	/**
	 * Adds error message if priority given is invalid
	 */
	void checkPriorityValid() {
		if (priority == null) {
			invalidArgs.add(MESSAGE_INVALID_PRIORITY);
		}
	}

	@Override
	void setProperParams() {
		itemID = argsArray.get(0).trim();
		item = getItemByID(itemID);
		if (argsArray.size() == 1) {
			priority = STRING_EMPTY;
		} else {
			priority = getPriority(argsArray.get(1).trim());
		}
	}

	@Override
	boolean validNumArgs() {
		if (this.count > 2 && this.count < 0) {
			return false;
		} else {
			return true;
		}
	}

	@Override
	Command getCommand() throws Exception {
		Command priority = new PriorityCommand(this.itemID, this.item,
				this.priority);
		return priority;
	}
}
```
###### parser\SearchParser.java
``` java
 */
public class SearchParser extends ArgsParserAbstract {

	/** Command parameters **/
	private String query;

	/**
	 * Constructor for SearchParser objects. Stores the correct arguments
	 * properly. Contains methods to display items containing query
	 * 
	 * @param args
	 * @throws Exception
	 */
	public SearchParser(String args) throws Exception {
		super(args);

		this.argsArray = splitArgs("", 1);
		this.count = argsArray.size();
		setProperParams();
	}

	@Override
	void setProperParams() {
		this.query = args.trim();
	}

	@Override
	boolean validNumArgs() {
		return true;
	}

	@Override
	Command getCommand() throws Exception {
		Command search = new SearchCommand(this.query);
		return search;
	}

}
```
###### parser\ShowParser.java
``` java
 */
public class ShowParser extends ArgsParserAbstract {

	/** Command parameters **/
	private ArrayList<String> tags;
	private String type;

	/**
	 * Constructor for ShowParser objects. Sets the command parameters with the
	 * proper inputs. Contains methods to display items that are tasks, events,
	 * containing specified tags, or all items
	 * 
	 * @param args
	 * @throws Exception
	 */
	public ShowParser(String args) throws Exception {
		super(args);

		this.argsArray = splitArgs(" ", -1);
		this.count = argsArray.size();

		setProperParams();
	}

	/**
	 * Sets the type of the show command to be all if no arguments are given, or
	 * to display tags if event/task is not given as the argument.
	 */
	void checkType() {
		if (type.equals("")) {
			this.type = "all";
		} else if (!type.equalsIgnoreCase("task")
				&& !type.equalsIgnoreCase("tasks")
				&& !type.equalsIgnoreCase("event")
				&& !type.equalsIgnoreCase("events")) {
			this.type = "tag";
		}
	}

	@Override
	void setProperParams() {
		this.type = argsArray.get(0).trim();
		this.tags = null;
		checkType();
		this.tags = this.argsArray;
	}

	@Override
	boolean validNumArgs() {
		return true;
	}

	@Override
	Command getCommand() throws Exception {
		Command show = new ShowCommand(this.type, this.tags);
		return show;
	}
}
```
###### parser\SortParser.java
``` java
 */
public class SortParser extends ArgsParserAbstract {

	/** Messaging **/
	private static final String MESSAGE_INVALID_FORMAT = "Use Format: sort <parameter> (upto 3 parameters)";
	private static final String MESSAGE_INVALID_PARAMS = "Parameters";

	/** Command parameters **/
	private ArrayList<String> sortParams;

	/**
	 * Constructor for SortParser objects. Checks if arguments are valid and
	 * stores the correct arguments properly. Throws the appropriate exception
	 * if arguments are invalid. Contains methods to sort the displayed tasks.
	 * 
	 * @param args
	 * @throws Exception
	 */
	public SortParser(String args) throws Exception {
		super(args);
		this.argsArray = splitArgs(" ", 3);
		this.count = argsArray.size();
		setProperParams();

		if (validNumArgs()) {
			checkParams();
			errorInvalidArgs();
		} else {
			errorInvalidFormat(MESSAGE_INVALID_FORMAT);
		}
	}

	/**
	 * Set the sorting parameters to all types if none are specified, else add
	 * error message
	 */
	void checkParams() {
		if (sortParams.size() == 1 && sortParams.get(0).isEmpty()) {
			sortParams.add("priority");
			sortParams.add("date");
			sortParams.add("title");
		} else if (!isValidSortParams()) {
			invalidArgs.add(MESSAGE_INVALID_PARAMS);
		}
	}

	/**
	 * Returns true if sort parameters are valid (priority, title, date), or
	 * false otherwise
	 * 
	 * @return whether sort paramters are valid
	 */
	private boolean isValidSortParams() {
		for (String param : sortParams) {
			if (!(param.equals("priority") || param.equals("title") || param
					.equals("date"))) {
				return false;
			}
		}
		return true;
	}

	@Override
	void setProperParams() {
		this.sortParams = argsArray;
	}

	@Override
	boolean validNumArgs() {
		if (count > 3) {
			return false;
		} else {
			return true;
		}
	}

	@Override
	Command getCommand() throws Exception {
		Command sort = new SortCommand(this.sortParams);
		return sort;
	}

}
```
###### parser\TagParser.java
``` java
 */
public class TagParser extends ArgsParserAbstract {

	/** Messaging **/
	private static final String MESSAGE_INVALID_FORMAT = "Use Format: tag <item_id> <tag name>";
	private static final String MESSAGE_INVALID_ITEM_ID = "item_id";
	private static final String MESSAGE_TAG_PRESENT = "%s already has tag: ";
	private static final String MESSAGE_TAG_RESTRICTED = "%s cannot have tag: ";

	/** For Checking **/
	private static final ArrayList<String> RESTRICTED = new ArrayList<String>(
			Arrays.asList("event", "events", "task", "tasks", "done"));

	/** Command Parameters **/
	private Item item;
	private String itemID;
	private ArrayList<String> tags;
	private String presentTags = STRING_EMPTY;
	private String invalidTags = STRING_EMPTY;

	/**
	 * Constructor for TagParser objects. Checks if arguments are valid and
	 * stores the correct arguments properly. Throws the appropriate exception
	 * if arguments are invalid
	 * 
	 * @param args
	 * @throws Exception
	 */
	public TagParser(String args) throws Exception {
		super(args);
		this.argsArray = splitArgs(" ", -1);
		this.count = argsArray.size();

		if (validNumArgs()) {
			setProperParams();

			checkItemExists();
			errorInvalidArgs();

			checkTags();
			errorInvalidArgs();
		} else {
			errorInvalidFormat(MESSAGE_INVALID_FORMAT);
		}
	}

	/**
	 * Checks if tags already exist or are restricted
	 */
	void checkTags() {
		Set<String> currentTags = item.getTags();
		for (String tag : tags) {
			checkTagsExist(currentTags, tag);
			checkRestricted(currentTags, tag);
		}
		addTagExistError();

		addTagRestrictedError();
	}

	/**
	 * Adds error message if given tags are restricted
	 */
	void addTagRestrictedError() {
		if (!invalidTags.equals("")) {
			invalidArgs.add(invalidTags);
		}
	}

	/**
	 * Adds error message if given tags already exist
	 */
	void addTagExistError() {
		if (!presentTags.equals("")) {
			invalidArgs.add(presentTags);
		}
	}

	/**
	 * Adds error message if item does not exist or unable to get
	 */
	void checkItemExists() {
		if (item == null) {
			invalidArgs.add(MESSAGE_INVALID_ITEM_ID);
		}
	}

	/**
	 * Check if a tag is present inside a set of tags and add to return message
	 * presentTags if it is. Returns true if there are present tags, or false
	 * otherwise.
	 * 
	 * @param currentTags
	 * @param tag
	 * @return boolean
	 */
	private boolean checkTagsExist(Set<String> currentTags, String tag) {
		if (currentTags.contains(tag)) {
			if (presentTags.equals(STRING_EMPTY)) {
				presentTags = String.format(MESSAGE_TAG_PRESENT, itemID) + tag;
				return true;
			} else {
				presentTags += ", " + tag;
				return true;
			}
		}
		return false;
	}

	/**
	 * Check if a tag is restricted and add to return message invalidTags if it
	 * is. Returns true if tag is restricted, or false otherwise.
	 * 
	 * @param currentTags
	 * @param tag
	 * @return boolean
	 */
	private boolean checkRestricted(Set<String> currentTags, String tag) {
		if (RESTRICTED.contains(tag.toLowerCase())) {
			if (invalidTags.equals(STRING_EMPTY)) {
				invalidTags = String.format(MESSAGE_TAG_RESTRICTED, itemID)
						+ tag;
			} else {
				invalidTags += ", " + tag;
			}
		}
		return false;
	}

	@Override
	void setProperParams() {
		this.itemID = argsArray.get(0).trim();
		this.item = getItemByID(itemID);
		this.tags = new ArrayList<String>(argsArray.subList(1, count));
	}

	@Override
	boolean validNumArgs() {
		if (this.count < 2) {
			return false;
		} else {
			return true;
		}
	}

	@Override
	Command getCommand() throws Exception {
		Command tag = new TagCommand(this.itemID, this.item, this.tags);
		return tag;
	}
}
```
###### parser\UndoneParser.java
``` java
 */
public class UndoneParser extends ArgsParserAbstract {

	/** Messaging **/
	private static final String MESSAGE_INVALID_FORMAT = "Use Format: undone <item_id>";
	private static final String MESSAGE_INVALID_ITEM_ID = "item_id";
	private static final String MESSAGE_INVALID_UNDONE = "Undone tasks cannot be undone";

	/** Command Parameters **/
	private Item item;
	private String itemID;

	/**
	 * Constructor for DoneParser objects. Checks if arguments are valid and
	 * stores the correct arguments properly. Throws the appropriate exception
	 * if arguments are invalid. Contains methods to move item to undone list.
	 * 
	 * @param args
	 * @throws Exception
	 */
	public UndoneParser(String args) throws Exception {
		super(args);
		this.argsArray = splitArgs(" ", -1);
		this.count = argsArray.size();

		if (validNumArgs()) {
			setProperParams();
			checkItemUndone();
			errorInvalidArgs();
		} else {
			errorInvalidFormat(MESSAGE_INVALID_FORMAT);
		}
	}

	/**
	 * Adds error message if item does not exist or unable to get or is already
	 * done
	 */
	void checkItemUndone() {
		if (item == null) {
			invalidArgs.add(MESSAGE_INVALID_ITEM_ID);
		} else if (argsArray.get(0).trim().contains("t")
				|| argsArray.get(0).trim().contains("e")) {
			invalidArgs.add(MESSAGE_INVALID_UNDONE);
		}
	}

	@Override
	void setProperParams() {
		itemID = argsArray.get(0).trim();
		item = getItemByID(itemID);
	}

	@Override
	boolean validNumArgs() {
		if (this.count != 1) {
			return false;
		} else {
			return true;
		}
	}

	@Override
	Command getCommand() throws Exception {
		Command undone = new UndoneCommand(this.itemID, this.item);
		return undone;
	}
}
```
###### parser\UntagParser.java
``` java
 */
public class UntagParser extends ArgsParserAbstract {

	/** Messaging **/
	private static final String MESSAGE_INVALID_FORMAT = "Use Format: untag <item_id> <tag name>";
	private static final String MESSAGE_INVALID_ITEM_ID = "item_id";
	private static final String MESSAGE_TAG_ABSENT = "%s does not have tag: ";

	/** Command Parameters **/
	private Item item;
	private String itemID;
	private ArrayList<String> tags;
	private String absentTags = STRING_EMPTY;

	/**
	 * Constructor for UntagParser objects. Checks if arguments are valid and
	 * stores the correct arguments properly. Throws the appropriate exception
	 * if arguments are invalid
	 * 
	 * @param args
	 * @throws Exception
	 */
	public UntagParser(String args) throws Exception {
		super(args);

		this.argsArray = splitArgs(" ", -1);
		this.count = argsArray.size();

		if (validNumArgs()) {
			setProperParams();

			checkItemExists();
			errorInvalidArgs();

			checkTags();
			errorInvalidArgs();
		} else {
			errorInvalidFormat(MESSAGE_INVALID_FORMAT);
		}
	}

	/**
	 * Checks if tags already exist or are restricted
	 */
	void checkTags() {
		Set<String> currentTags = item.getTags();
		for (String tag : tags) {
			checkTagsNotExist(currentTags, tag);
		}
		addTagsAbsentError();
	}

	/**
	 * Adds error message if given tags are absent from item
	 */
	void addTagsAbsentError() {
		if (!absentTags.equals("")) {
			invalidArgs.add(absentTags);
		}
	}

	/**
	 * Adds error message if item does not exist or unable to get
	 */
	void checkItemExists() {
		if (item == null) {
			invalidArgs.add(MESSAGE_INVALID_ITEM_ID);
		}
	}

	/**
	 * Check if a tag is absent in a set of tags and add to return message
	 * absentTags if it is not. Returns true if there are absent tags, or false
	 * otherwise.
	 * 
	 * @param currentTags
	 * @param tag
	 * @return boolean
	 */
	private boolean checkTagsNotExist(Set<String> currentTags, String tag) {
		if (!currentTags.contains(tag)) {
			if (absentTags.equals(STRING_EMPTY)) {
				absentTags = String.format(MESSAGE_TAG_ABSENT, itemID) + tag;
				return true;
			} else {
				absentTags += ", " + tag;
				return true;
			}
		}
		return false;
	}

	@Override
	void setProperParams() {
		this.itemID = argsArray.get(0).trim();
		this.item = getItemByID(itemID);
		this.tags = new ArrayList<String>(argsArray.subList(1, count));
	}

	@Override
	boolean validNumArgs() {
		if (this.count < 2) {
			return false;
		} else {
			return true;
		}
	}

	@Override
	Command getCommand() throws Exception {
		Command untag = new UntagCommand(this.itemID, this.item, this.tags);
		return untag;
	}
}
```
