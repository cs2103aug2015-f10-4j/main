# A0127127L
###### gui\FXML.fxml
``` fxml

<?import javafx.scene.shape.*?>
<?import javafx.scene.text.*?>
<?import javafx.geometry.*?>
<?import java.lang.*?>
<?import javafx.scene.control.*?>
<?import javafx.scene.layout.*?>
<?import javafx.scene.layout.AnchorPane?>

<AnchorPane fx:id="rootPane" focusTraversable="true" prefHeight="800.0" prefWidth="850.0" styleClass="root-pane" stylesheets="@main.css" xmlns="http://javafx.com/javafx/8" xmlns:fx="http://javafx.com/fxml/1" fx:controller="gui.GUIController">
   <children>
      <StackPane AnchorPane.bottomAnchor="0.0" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0">
         <children>
            <AnchorPane fx:id="mainPane">
               <children>
                  <VBox focusTraversable="true" maxHeight="1.7976931348623157E308" maxWidth="1.7976931348623157E308" AnchorPane.bottomAnchor="0.0" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0">
                     <children>
                        <TabPane fx:id="tabPane" tabClosingPolicy="UNAVAILABLE" VBox.vgrow="ALWAYS">
                          <tabs>
                            <Tab fx:id="taskTab" closable="false" onSelectionChanged="#handleTaskTabClicked" text="Tasks">
                              <content>
                                <AnchorPane minHeight="0.0" minWidth="0.0" prefHeight="180.0" prefWidth="200.0">
                                       <children>
                                          <VBox prefHeight="200.0" prefWidth="100.0" spacing="5.0" AnchorPane.bottomAnchor="0.0" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0">
                                             <children>
                                                <Label styleClass="label-header" text="To-Do">
                                                   <font>
                                                      <Font name="System Bold" size="20.0" />
                                                   </font>
                                                </Label>
                                                <TableView fx:id="taskTable" VBox.vgrow="ALWAYS">
                                                  <columns>
                                                    <TableColumn fx:id="taskIDCol" maxWidth="40.0" minWidth="40.0" prefWidth="40.0" sortable="false" text="ID" />
                                                    <TableColumn fx:id="taskTitleCol" minWidth="250.0" prefWidth="250.0" sortable="false" text="Title" />
                                                      <TableColumn fx:id="taskDueDateCol" minWidth="200.0" prefWidth="200.0" sortable="false" text="Due Date" />
                                                      <TableColumn fx:id="taskTagsCol" minWidth="150.0" prefWidth="125.0" sortable="false" text="Tags" />
                                                      <TableColumn fx:id="taskPriorityCol" minWidth="80.0" sortable="false" text="Priority" />
                                                  </columns>
                                                   <columnResizePolicy>
                                                      <TableView fx:constant="CONSTRAINED_RESIZE_POLICY" />
                                                   </columnResizePolicy>
                                                </TableView>
                                                <Label styleClass="label-header" text="Done">
                                                   <font>
                                                      <Font name="System Bold" size="20.0" />
                                                   </font>
                                                </Label>
                                                <TableView fx:id="taskDoneTable" layoutX="10.0" layoutY="45.0" prefHeight="250.0">
                                                   <columnResizePolicy>
                                                      <TableView fx:constant="CONSTRAINED_RESIZE_POLICY" />
                                                   </columnResizePolicy>
                                                   <columns>
                                                      <TableColumn fx:id="taskDoneIDCol" maxWidth="40.0" minWidth="40.0" prefWidth="40.0" sortable="false" text="ID" />
                                                      <TableColumn fx:id="taskDoneTitleCol" minWidth="250.0" prefWidth="250.0" sortable="false" text="Title" />
                                                      <TableColumn fx:id="taskDoneDueDateCol" minWidth="200.0" prefWidth="200.0" sortable="false" text="Due Date" />
                                                      <TableColumn fx:id="taskDoneTagsCol" minWidth="150.0" prefWidth="150.0" sortable="false" text="Tags" />
                                                      <TableColumn fx:id="taskDonePriorityCol" minWidth="80.0" prefWidth="100.0" sortable="false" text="Priority" />
                                                   </columns>
                                                </TableView>
                                             </children>
                                             <padding>
                                                <Insets top="5.0" />
                                             </padding>
                                          </VBox>
                                       </children>
                                    </AnchorPane>
                              </content>
                            </Tab>
                            <Tab fx:id="eventTab" closable="false" onSelectionChanged="#handleEventTabClicked" text="Events">
                              <content>
                                <AnchorPane minHeight="0.0" minWidth="0.0" prefHeight="180.0" prefWidth="200.0">
                                       <children>
                                          <VBox prefHeight="200.0" prefWidth="100.0" spacing="5.0" AnchorPane.bottomAnchor="0.0" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0">
                                             <children>
                                                <Label styleClass="label-header" text="Upcoming Events">
                                                   <font>
                                                      <Font name="System Bold" size="20.0" />
                                                   </font>
                                                </Label>
                                                <TableView fx:id="eventTable" VBox.vgrow="ALWAYS">
                                                   <columns>
                                                      <TableColumn fx:id="eventIDCol" maxWidth="40.0" minWidth="40.0" prefWidth="40.0" sortable="false" text="ID" />
                                                      <TableColumn fx:id="eventTitleCol" minWidth="200.0" prefWidth="200.0" sortable="false" text="Title" />
                                                      <TableColumn fx:id="eventStartDateCol" minWidth="200.0" prefWidth="200.0" sortable="false" text="Start Date" />
                                                      <TableColumn fx:id="eventEndDateCol" minWidth="200.0" prefWidth="200.0" sortable="false" text="End Date" />
                                                      <TableColumn fx:id="eventTagsCol" minWidth="100.0" prefWidth="100.0" sortable="false" text="Tags" />
                                                      <TableColumn fx:id="eventPriorityCol" minWidth="80.0" sortable="false" text="Priority" />
                                                   </columns>
                                                   <columnResizePolicy>
                                                      <TableView fx:constant="CONSTRAINED_RESIZE_POLICY" />
                                                   </columnResizePolicy>
                                                </TableView>
                                                <Label styleClass="label-header" text="Past Events">
                                                   <font>
                                                      <Font name="System Bold" size="20.0" />
                                                   </font>
                                                </Label>
                                                <TableView fx:id="eventDoneTable" layoutX="10.0" layoutY="45.0" prefHeight="250.0">
                                                   <columns>
                                                      <TableColumn fx:id="eventDoneIDCol" maxWidth="40.0" minWidth="40.0" prefWidth="40.0" sortable="false" text="ID" />
                                                      <TableColumn fx:id="eventDoneTitleCol" minWidth="200.0" prefWidth="200.0" sortable="false" text="Title" />
                                                      <TableColumn fx:id="eventDoneStartDateCol" minWidth="200.0" prefWidth="200.0" sortable="false" text="Start Date" />
                                                      <TableColumn fx:id="eventDoneEndDateCol" minWidth="200.0" prefWidth="200.0" sortable="false" text="End Date" />
                                                      <TableColumn fx:id="eventDoneTagsCol" minWidth="100.0" prefWidth="100.0" sortable="false" text="Tags" />
                                                      <TableColumn fx:id="eventDonePriorityCol" minWidth="80.0" prefWidth="8.0" sortable="false" text="Priority" />
                                                   </columns>
                                                   <columnResizePolicy>
                                                      <TableView fx:constant="CONSTRAINED_RESIZE_POLICY" />
                                                   </columnResizePolicy>
                                                </TableView>
                                             </children>
                                             <padding>
                                                <Insets top="5.0" />
                                             </padding>
                                          </VBox>
                                       </children>
                                    </AnchorPane>
                              </content>
                            </Tab>
                          </tabs>
                        </TabPane>
                        <Label fx:id="messageLabel" focusTraversable="false" text="Message Label" textFill="WHITE" wrapText="true">
                           <font>
                              <Font size="18.0" />
                           </font>
                        </Label>
                        <TextField fx:id="commandLineField" onKeyPressed="#handleKeyPressed" />
                     </children>
                     <padding>
                        <Insets bottom="10.0" left="10.0" right="10.0" top="10.0" />
                     </padding>
                  </VBox>
               </children></AnchorPane>
            <AnchorPane fx:id="helpPane" maxHeight="-Infinity" maxWidth="-Infinity" minHeight="-Infinity" minWidth="-Infinity" prefHeight="500.0" prefWidth="400.0" stylesheets="@help.css" StackPane.alignment="CENTER">
               <children>
                  <ScrollPane focusTraversable="false" prefHeight="442.0" prefWidth="439.0" styleClass="help-pane" AnchorPane.bottomAnchor="0.0" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0">
                    <content>
                      <AnchorPane maxHeight="5000.0" minHeight="0.0" minWidth="0.0" prefWidth="380.0" styleClass="help-inner-pane">
                           <children>
                              <VBox fx:id="helpVBox" styleClass="help-inner-pane" AnchorPane.bottomAnchor="0.0" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0">
                                 <children>
                                    <Label fx:id="headerLabel" focusTraversable="false" styleClass="header-label" text="Label" wrapText="true" />
                                    <Text fx:id="bodyText" strokeType="OUTSIDE" strokeWidth="0.0" styleClass="body-style" text="Text" wrappingWidth="360.0" />
                                 </children>
                              </VBox>
                           </children>
                           <padding>
                              <Insets bottom="10.0" left="10.0" right="10.0" top="10.0" />
                           </padding>
                        </AnchorPane>
                    </content>
                  </ScrollPane>
               </children>
               <StackPane.margin>
                  <Insets />
               </StackPane.margin>
            </AnchorPane>
         </children>
      </StackPane>
   </children>
</AnchorPane>
```
###### gui\GUIController.java
``` java
 */

public class GUIController {

	private static Logger logger = Logger.getLogger("GUIController");

	private static final String TASK_TABLE_LETTER = "t";
	private static final String TASK_DONE_TABLE_LETTER = "d";
	private static final String EVENT_TABLE_LETTER = "e";
	private static final String EVENT_DONE_TABLE_LETTER = "p";

	private static final String PRIORITY_HIGH_COLOR = "lightsalmon";
	private static final String PRIORITY_MEDIUM_COLOR = "moccasin";
	private static final String PRIORITY_LOW_COLOR = "lemonchiffon";
	private static final String PRIORITY_HIGH = "high";
	private static final String PRIORITY_MEDIUM = "medium";
	private static final String PRIORITY_LOW = "low";

	private static final String OVERDUE_ROW_COLOR = "lightpink";
	private static final Color SUCCESS_MESSAGE_COLOR = Color.web("#2eff00");
	private static final Color ERROR_MESSAGE_COLOR = Color.web("#ff8484");

	/** Shortcuts **/
	private static final String UNDO_COMMAND = "undo";
	private static final String REDO_COMMAND = "redo";
	private static final KeyCodeCombination SWITCH_TAB_SHORTCUT = new KeyCodeCombination(
			KeyCode.TAB, KeyCombination.CONTROL_DOWN);
	private static final KeyCodeCombination UNDO_SHORTCUT = new KeyCodeCombination(
			KeyCode.Z, KeyCombination.CONTROL_DOWN);
	private static final KeyCodeCombination REDO_SHORTCUT = new KeyCodeCombination(
			KeyCode.Y, KeyCombination.CONTROL_DOWN);
	private static final KeyCodeCombination GOTO_COMMANDLINE_SHORTCUT = new KeyCodeCombination(
			KeyCode.ENTER);
	private final EventHandler<KeyEvent> shortcutHandler = new EventHandler<KeyEvent>() {
		@Override
		public void handle(KeyEvent ke) {
			if (UNDO_SHORTCUT.match(ke)) {
				handleUserInput(UNDO_COMMAND);
			} else if (REDO_SHORTCUT.match(ke)) {
				handleUserInput(REDO_COMMAND);
			} else if (GOTO_COMMANDLINE_SHORTCUT.match(ke)) {
				commandLineField.requestFocus();
			} else if (SWITCH_TAB_SHORTCUT.match(ke)) {
				if (GUIModel.getCurrentTab() == "events") {
					switchToTab("tasks");
					GUIModel.setCurrentTab("tasks");
				} else if (GUIModel.getCurrentTab() == "tasks") {
					switchToTab("events");
					GUIModel.setCurrentTab("events");
				} else {

				}
			} else {
				return;
			}
		}
	};

	/** Containers **/
	@FXML
	private AnchorPane rootPane;
	@FXML
	private AnchorPane mainPane;
	@FXML
	private AnchorPane helpPane;

	/** Task Table Elements **/
	@FXML
	private TableView<Item> taskTable;
	@FXML
	private TableColumn<Item, String> taskIDCol;
	@FXML
	private TableColumn<Item, String> taskTitleCol;
	@FXML
	private TableColumn<Item, CustomDate> taskDueDateCol;
	@FXML
	private TableColumn<Item, String> taskPriorityCol;
	@FXML
	private TableColumn<Item, String> taskTagsCol;

	/** Done Task Table Elements **/
	@FXML
	private TableView<Item> taskDoneTable;
	@FXML
	private TableColumn<Item, String> taskDoneIDCol;
	@FXML
	private TableColumn<Item, String> taskDoneTitleCol;
	@FXML
	private TableColumn<Item, String> taskDoneDueDateCol;
	@FXML
	private TableColumn<Item, String> taskDonePriorityCol;
	@FXML
	private TableColumn<Item, String> taskDoneTagsCol;

	/** Event Table Elements **/
	@FXML
	private TableView<Item> eventTable;
	@FXML
	private TableColumn<Item, String> eventIDCol;
	@FXML
	private TableColumn<Item, String> eventTitleCol;
	@FXML
	private TableColumn<Item, CustomDate> eventStartDateCol;
	@FXML
	private TableColumn<Item, String> eventEndDateCol;
	@FXML
	private TableColumn<Item, String> eventPriorityCol;
	@FXML
	private TableColumn<Item, String> eventTagsCol;

	/** Done Event Table Elements **/
	@FXML
	private TableView<Item> eventDoneTable;
	@FXML
	private TableColumn<Item, String> eventDoneIDCol;
	@FXML
	private TableColumn<Item, String> eventDoneTitleCol;
	@FXML
	private TableColumn<Item, String> eventDoneStartDateCol;
	@FXML
	private TableColumn<Item, String> eventDoneEndDateCol;
	@FXML
	private TableColumn<Item, String> eventDonePriorityCol;
	@FXML
	private TableColumn<Item, String> eventDoneTagsCol;

	/** Help Elements **/
	@FXML
	private Label headerLabel;
	@FXML
	private Text bodyText;
	@FXML
	private VBox helpVBox;

	/** Other Controls **/
	@FXML
	private TabPane tabPane;
	@FXML
	private Tab taskTab;
	@FXML
	private Tab eventTab;
	@FXML
	private Label messageLabel;
	@FXML
	private TextField commandLineField;

	/** PUBLIC METHODS **/

	/**
	 * This method initializes GUIController when the FXML file is loaded by
	 * GUIView.
	 * 
	 * @throws Exception
	 */
	public void initialize() throws Exception {

		Magical.init();
		GUIModel.update();

		messageLabel.setText("What would you like to do?");

		updateTables();

		initializeTaskTableColumns();
		initializeTaskDoneTableColumns();

		initializeEventTableColumns();
		initializeEventDoneTableColumns();

		updateTableColors();

		/** Help Controls **/
		headerLabel.setText(Help.HEADER_TEXT);
		bodyText.setText(Help.BODY_TEXT);

		/** For dealing with controls that need to be initialized first **/
		Platform.runLater(new Runnable() {
			@Override
			public void run() {
				commandLineField.requestFocus();
				helpPane.setVisible(false);
				mainPane.toFront();
				initializeSceneShortcuts();
			}
		});

	}

	/**
	 * This method switches the currently selected tab.
	 * 
	 * @param type
	 *            either "tasks" or "events"
	 */
	public void switchToTab(String type) {
		SingleSelectionModel<Tab> selectionModel = tabPane.getSelectionModel();
		if (type == "tasks") {
			selectionModel.select(taskTab);
		} else if (type == "events") {
			selectionModel.select(eventTab);
		}
		return;
	}

	/**
	 * Hides the help pane if any key is pressed when the command line is in
	 * focus.
	 *
	 * Handles input from commandLineField by checking if the Enter key has been
	 * pressed, reading user input and passing it to the main application logic
	 * via main.Magical.parseCommand. If the user input throws an exception, the
	 * error message is printed into the label above the command line.
	 *
	 * Also checks if GUIModel.showHelpWindow is true, and opens the help window
	 * accordingly.
	 * 
	 * @param event
	 *            a key event in the commandLineField
	 * @throws Exception
	 */
	@FXML
	protected void handleKeyPressed(KeyEvent event) throws Exception {
		if (event.getCode() == KeyCode.ENTER) {
			helpPane.setVisible(false);
			mainPane.toFront();
			String userInput = commandLineField.getText();
			handleUserInput(userInput);
		}
		if (GUIModel.showHelpWindow) {
			helpPane.setVisible(true);
			helpPane.toFront();
			Magical.setShowHelpWindow(false);
			GUIModel.update();
		}
		commandLineField.requestFocus();
	}

	/**
	 * Passes userInput to the main application logic, printing an error message
	 * when applicable. Also used when implementing shortcuts that simulate user
	 * input.
	 * 
	 * @param userInput
	 *            usually from commandLine
	 */
	private void handleUserInput(String userInput) {
		logger.log(Level.INFO, "> " + userInput);
		try {
			messageLabel.setTextFill(SUCCESS_MESSAGE_COLOR);
			String message = main.Magical.execute(userInput);
			logger.log(Level.INFO, message);
			messageLabel.setText(message);
			commandLineField.clear();
			GUIModel.update();
			updateTables();
			updateTableColors();
			switchToTab(GUIModel.getCurrentTab());
		} catch (Exception e) {
			e.printStackTrace();
			logger.log(Level.WARNING, e.getMessage());
			messageLabel.setTextFill(ERROR_MESSAGE_COLOR);
			messageLabel.setText(e.getMessage());
		}
	}

	/**
	 * Initializes event handlers for the main scene. Must be called after
	 * initialization of the controller.
	 * 
	 * @return nothing
	 */

	private void initializeSceneShortcuts() {
		Scene scene = rootPane.getScene();
		scene.setOnKeyPressed(shortcutHandler);
		commandLineField.addEventHandler(KeyEvent.KEY_PRESSED, shortcutHandler);
	}

	/**
	 * Updates tables with their respective counterparts in GUIModel.
	 *
	 * @return nothing
	 */
	private void updateTables() {
		taskTable.setItems(GUIModel.getTaskList());
		taskDoneTable.setItems(GUIModel.getTaskDoneList());
		eventTable.setItems(GUIModel.getEventList());
		eventDoneTable.setItems(GUIModel.getEventDoneList());
	}

	/**
	 * These methods set the current tab of the GUIModel to the tab last clicked
	 * by the user. They are assigned to their respective tabs in the FXML file.
	 * 
	 * @return nothing
	 */
	@FXML
	private void handleTaskTabClicked() {
		Magical.setCurrentTab("tasks");
		GUIModel.setCurrentTab("tasks");
	}

	@FXML
	private void handleEventTabClicked() {
		Magical.setCurrentTab("events");
		GUIModel.setCurrentTab("events");
	}

	/**
	 * Initializes table columns for the done event table.
	 * 
	 * @return nothing
	 */
	private void initializeEventDoneTableColumns() {
		eventDoneIDCol.setCellFactory(col -> {
			return makeIndex(EVENT_DONE_TABLE_LETTER);
		});
		eventDoneTitleCol
				.setCellValueFactory(new PropertyValueFactory<Item, String>(
						"title"));
		eventDoneTagsCol.setCellValueFactory(col -> {
			return makeTagCellValue(col);
		});
		eventDoneStartDateCol
				.setCellValueFactory(new PropertyValueFactory<Item, String>(
						"startDate"));
		eventDoneEndDateCol
				.setCellValueFactory(new PropertyValueFactory<Item, String>(
						"endDate"));
		eventDonePriorityCol
				.setCellValueFactory(new PropertyValueFactory<Item, String>(
						"priority"));
	}

	/**
	 * Initializes table columns for the event table.
	 * 
	 * @return nothing
	 */
	private void initializeEventTableColumns() {
		eventIDCol.setCellFactory(col -> {
			return makeIndex(EVENT_TABLE_LETTER);
		});
		eventTitleCol
				.setCellValueFactory(new PropertyValueFactory<Item, String>(
						"title"));
		eventTagsCol.setCellValueFactory(col -> {
			return makeTagCellValue(col);
		});
		eventStartDateCol
				.setCellValueFactory(new PropertyValueFactory<Item, CustomDate>(
						"startDate"));
		eventEndDateCol
				.setCellValueFactory(new PropertyValueFactory<Item, String>(
						"endDate"));
		eventPriorityCol
				.setCellValueFactory(new PropertyValueFactory<Item, String>(
						"priority"));
	}

	/**
	 * Initializes table columns for the done task table.
	 * 
	 * @return nothing
	 */
	private void initializeTaskDoneTableColumns() {
		taskDoneIDCol.setCellFactory(col -> {
			return makeIndex(TASK_DONE_TABLE_LETTER);
		});
		taskDoneTitleCol
				.setCellValueFactory(new PropertyValueFactory<Item, String>(
						"title"));
		taskDoneTagsCol.setCellValueFactory(col -> {
			return makeTagCellValue(col);
		});
		taskDoneDueDateCol
				.setCellValueFactory(new PropertyValueFactory<Item, String>(
						"endDate"));
		taskDonePriorityCol
				.setCellValueFactory(new PropertyValueFactory<Item, String>(
						"priority"));
	}

	/**
	 * Initializes table columns for task table.
	 * 
	 * @return nothing
	 */
	private void initializeTaskTableColumns() {
		taskIDCol.setCellFactory(col -> {
			return makeIndex(TASK_TABLE_LETTER);
		});
		taskTitleCol
				.setCellValueFactory(new PropertyValueFactory<Item, String>(
						"title"));
		taskTagsCol.setCellValueFactory(col -> {
			return makeTagCellValue(col);
		});
		taskDueDateCol
				.setCellValueFactory(new PropertyValueFactory<Item, CustomDate>(
						"endDate"));
		taskPriorityCol
				.setCellValueFactory(new PropertyValueFactory<Item, String>(
						"priority"));
	}

	/**
	 * This method converts a tagSet into a printable String to populate Tags
	 * columns with.
	 * 
	 * @param tagSet
	 *            set of tags from an Item
	 * @return String
	 */
	private String makeTagString(Set<String> tagSet) {
		String result = "";
		if (!tagSet.isEmpty()) {
			Iterator<String> iterator = tagSet.iterator();
			while (iterator.hasNext()) {
				result += iterator.next() + ", ";
			}
			result = result.substring(0, result.lastIndexOf(","));
		}
		return result;
	}

	/**
	 * Returns a SimpleStringProperty of a cell's Item's tags.
	 * 
	 * @param col
	 * @return SimpleStringProperty
	 */
	private SimpleStringProperty makeTagCellValue(
			CellDataFeatures<Item, String> col) {
		SimpleStringProperty finalResult = new SimpleStringProperty();
		Set<String> tagSet = col.getValue().getTags();
		String result = makeTagString(tagSet);
		finalResult.setValue(result);
		return finalResult;
	}

	/**
	 * Makes the appropriate index cell for table columns.
	 * 
	 * @param character
	 *            depending on table
	 * @return TableCell
	 */
	private TableCell<Item, String> makeIndex(String character) {
		TableCell<Item, String> cell = new TableCell<>();
		cell.textProperty().bind(
				Bindings.when(cell.emptyProperty())
						.then("")
						.otherwise(
								Bindings.concat(character, cell.indexProperty()
										.add(1).asString())));
		return cell;
	}

	/**
	 * Creates a table cell for dates in columns that colors the whole row red
	 * if the date is past. As such, this method is only used for the undone
	 * event and task tables.
	 * 
	 * @return TableCell<Item, CustomDate> with a colored row depending on date
	 */
	private TableCell<Item, CustomDate> makeDateCellFactory() {
		return new TableCell<Item, CustomDate>() {
			@Override
			protected void updateItem(CustomDate item, boolean empty) {
				super.updateItem(item, empty);
				if (item == null || empty) {
					setText("");
					setStyle("");
				} else {
					setText(item.toString());
					Calendar cal = Calendar.getInstance();
					CustomDate currDate = new CustomDate(cal.getTime());
					if (item.compareTo(currDate) <= 0) {
						getTableRow().setStyle(
								"-fx-background-color: " + OVERDUE_ROW_COLOR);
					}
				}
			}
		};
	}

	/**
	 * Creates a table cell for priority columns that colors the cell depending
	 * on priority.
	 * 
	 * @return TableCell<Item, CustomDate> with a colored row depending on date
	 */
	private TableCell<Item, String> makePriorityCellFactory() {
		return new TableCell<Item, String>() {
			@Override
			protected void updateItem(String item, boolean empty) {
				super.updateItem(item, empty);
				if (item == null || empty) {
					setText("");
					setStyle("");
				} else {
					setText(item);
					if (!getTableRow().getStyle().isEmpty()) {
						return;
					} else if (item.equals(PRIORITY_HIGH)) {
						setStyle("-fx-background-color: " + PRIORITY_HIGH_COLOR);
					} else if (item.equals(PRIORITY_MEDIUM)) {
						setStyle("-fx-background-color: "
								+ PRIORITY_MEDIUM_COLOR);
					} else if (item.equals(PRIORITY_LOW)) {
						setStyle("-fx-background-color: " + PRIORITY_LOW_COLOR);
					} else {
					}
					return;
				}
			}
		};
	}

	/**
	 * Updates row colors of the task table and event table. Needs to be called
	 * after every command.
	 * 
	 * @return nothing
	 */
	private void updateTableColors() {
		taskDueDateCol.setCellFactory(col -> {
			return makeDateCellFactory();
		});
		eventStartDateCol.setCellFactory(col -> {
			return makeDateCellFactory();
		});
		taskPriorityCol.setCellFactory(col -> {
			return makePriorityCellFactory();
		});
		taskDonePriorityCol.setCellFactory(col -> {
			return makePriorityCellFactory();
		});
		eventPriorityCol.setCellFactory(col -> {
			return makePriorityCellFactory();
		});
		eventDonePriorityCol.setCellFactory(col -> {
			return makePriorityCellFactory();
		});

	}

}
```
###### gui\GUIModel.java
``` java
 */

public class GUIModel {

	public static boolean showHelpWindow = false;

	public static String currentTab = "tasks";

	public static ObservableList<Item> taskList;
	public static ObservableList<Item> taskDoneList;
	public static ObservableList<Item> eventList;
	public static ObservableList<Item> eventDoneList;

	@FXML
	private AnchorPane rootPane;

	/**
	 * This method sets the current tab in the model.
	 * 
	 * @param type
	 *            "tasks" or "events"
	 */

	public static void setCurrentTab(String type) {
		if (type == "tasks") {
			currentTab = type;
		} else if (type == "events") {
			currentTab = type;
		}
	}

	/**
	 * Returns the current tab in the model.
	 * 
	 * @return String "events" or "tasks"
	 */
	public static String getCurrentTab() {
		return currentTab;
	}

	/**
	 * The methods below return the various lists stored in the model.
	 * 
	 * @return ObservableList<Item>
	 */
	public static ObservableList<Item> getTaskList() {
		return taskList;
	}

	public static ObservableList<Item> getTaskDoneList() {
		return taskDoneList;
	}

	public static ObservableList<Item> getEventList() {
		return eventList;
	}

	public static ObservableList<Item> getEventDoneList() {
		return eventDoneList;
	}

	/**
	 * The methods below allow the lists in the model to be replaced.
	 * 
	 * @param newTaskList
	 */
	public static void setTaskList(ArrayList<Item> newTaskList) {
		taskList = makeObservable(newTaskList);
	}

	public static void setTaskDoneList(ArrayList<Item> newTaskDoneList) {
		taskDoneList = makeObservable(newTaskDoneList);
	}

	public static void setEventList(ArrayList<Item> newEventList) {
		eventList = makeObservable(newEventList);
	}

	public static void setEventDoneList(ArrayList<Item> newEventDoneList) {
		eventDoneList = makeObservable(newEventDoneList);
	}

	/**
	 * This method updates GUIModel with lists from the main application.
	 * 
	 * @return Nothing
	 */
	public static void update() {
		currentTab = Magical.getCurrentTab();
		showHelpWindow = Magical.isShowHelpWindow();
		setTaskList(Magical.getDisplayList(Storage.TASKS_INDEX));
		setTaskDoneList(Magical.getDisplayList(Storage.TASKS_DONE_INDEX));
		setEventList(Magical.getDisplayList(Storage.EVENTS_INDEX));
		setEventDoneList(Magical.getDisplayList(Storage.EVENTS_DONE_INDEX));
	}

	/**
	 * This method converts an ArrayList of tasks into an ObservableList.
	 * 
	 * @param arrayList
	 *            list to convert
	 * @return ObservableList
	 */
	private static ObservableList<Item> makeObservable(ArrayList<Item> arrayList) {
		return FXCollections.observableArrayList(arrayList);
	}

}
```
###### gui\GUIView.java
``` java
 */

public class GUIView extends Application {

	private static final String TITLE = "Magical";
	private static final String TITLE_FORMAT = "Magical v%s";
	private static final String VERSION_NUMBER = "0.5";

	private static boolean showVersionNumber = false;

	/**
	 * Initializes the main scene of the application, by loading the FXML file
	 * and its controller.
	 * 
	 * @return nothing
	 */
	public void start(Stage primaryStage) throws Exception {
		primaryStage.setTitle(showVersionNumber ? String.format(TITLE_FORMAT,
				VERSION_NUMBER) : TITLE);
		Pane rootPane = (Pane) FXMLLoader.load(getClass().getResource(
				"/gui/FXML.fxml"));
		Scene scene = new Scene(rootPane);
		primaryStage.getIcons().add(new Image("/gui/magicalLogo.png"));
		primaryStage.setScene(scene);
		primaryStage.show();
	}

	/**
	 * Main method. Launches application.
	 * 
	 * @param args
	 */
	public static void main(String[] args) {
		LauncherImpl.launchApplication(GUIView.class, args);
	}

}
```
###### gui\help.css
``` css
.help-pane{
	-fx-background: linear-gradient(white, #C1C1E0);
	-fx-effect: innershadow(two-pass-box , rgba(0,0,0,0.5) , 8, 0.0 , 0 , 0);
}
.help-inner-pane{
	-fx-background-color: transparent;
}
.header-label {
	-fx-underline: true;
	-fx-font-size: 18;
	-fx-font-weight: bold;
}
.body-text {
	-fx-font-size: 15;
	-fx-text-alignment: justify;
}
```
###### gui\Help.java
``` java
 */

public class Help {

	public static final String ENDL = System.getProperty("line.separator");

	public static final String HEADER_TEXT = "Magical User Guide";

	public static final String BODY_TEXT = "Press the Enter key to close this window."
			+ ENDL
			+ ENDL
			+ "Sample formats for dates and times:"
			+ ENDL
			+ "- today"
			+ ENDL
			+ "- today 2359"
			+ ENDL
			+ "- tomorrow 5pm"
			+ ENDL
			+ "- Jan 1 10am"
			+ ENDL
			+ "- 31 December 5.30pm"
			+ ENDL
			+ ENDL
			+ "To add a task:"
			+ ENDL
			+ "> add [task title] by [due date]"
			+ ENDL
			+ ENDL
			+ "To add an event:"
			+ ENDL
			+ "> event [title] from [start date] [start time] to [end date] [end time]"
			+ ENDL
			+ ENDL
			+ "To mark an item as 'done':"
			+ ENDL
			+ "> done [item ID]"
			+ ENDL
			+ ENDL
			+ "To mark a done item as 'undone':"
			+ ENDL
			+ "> undone [done item ID]"
			+ ENDL
			+ ENDL
			+ "To delete an item:"
			+ ENDL
			+ "> delete [item ID]"
			+ ENDL
			+ ENDL
			+ "To edit an item:"
			+ ENDL
			+ "> edit [item ID] [field] [updated value]"
			+ ENDL
			+ ENDL
			+ "To tag an item:"
			+ ENDL
			+ "> tag [item ID] [tag name]"
			+ ENDL
			+ ENDL
			+ "To untag an item:"
			+ ENDL
			+ "> untag [item ID] [tag name]"
			+ ENDL
			+ ENDL
			+ "To show all tasks:"
			+ ENDL
			+ "> show"
			+ ENDL
			+ ENDL
			+ "To show a different tab:"
			+ ENDL
			+ "> show [tasks / events]"
			+ ENDL
			+ ENDL
			+ "To show items of a certain tag:"
			+ ENDL
			+ "> show [tag name]"
			+ ENDL
			+ ENDL
			+ "To sort items:"
			+ ENDL
			+ "> sort [priority / date / title]"
			+ ENDL
			+ ENDL
			+ "To search for an item:"
			+ ENDL
			+ "> search [query]"
			+ ENDL
			+ ENDL
			+ "To change an item's priority:"
			+ ENDL
			+ "> set [item ID] [high / medium / low / empty]"
			+ ENDL
			+ ENDL
			+ "To undo a previous action:"
			+ ENDL
			+ "> undo"
			+ ENDL
			+ "or use the shortcut Ctrl + Z"
			+ ENDL
			+ ENDL
			+ "To redo an undone action:"
			+ ENDL
			+ "> redo"
			+ ENDL
			+ "or use the shortcut Ctrl + Y"
			+ ENDL
			+ ENDL
			+ "To change where your list is stored:"
			+ ENDL
			+ "> path [filepath]"
			+ ENDL
			+ ENDL
			+ "To exit the application:"
			+ ENDL + "> exit" + ENDL + ENDL + ENDL;

}
```
###### gui\main.css
``` css
.root-pane {
	-fx-background-color: linear-gradient(#9F9FCF, midnightblue);
}
.label-header {
	-fx-text-fill: #FFFFFF;
}
.tab-pane {
	-fx-skin: "com.sun.javafx.scene.control.skin.TabPaneSkin";
}
.tab-pane *.tab-header-background {
    -fx-background-color: #57578C;
    -fx-effect: innershadow(two-pass-box , rgba(0,0,0,0.6) , 4, 0.0 , 0 , 0);
}
```
###### parser\EditParserTest.java
``` java
 */

import java.util.ArrayList;
import java.util.Arrays;

import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;

import gui.GUIModel;
import main.Item;

public class EditParserTest {

	protected static final String MESSAGE_HEADER_INVALID = "Invalid arguments: %s";
	private static final String MESSAGE_INVALID_FORMAT = "Use format: edit <item_id> <field> <value>";
	private static final String MESSAGE_INVALID_FIELD = "Unknown field";
	private static final String MESSAGE_INVALID_TASK_START = "Task cannot have start time";
	private static final String MESSAGE_INVALID_DATE = "Date";
	private static final String MESSAGE_INVALID_TIME_END = "End time";
	private static final String MESSAGE_INVALID_TIME_START = "Start time";
	private static final String MESSAGE_INVALID_ITEM_ID = "item_id";
	private static final String MESSAGE_INVALID_TITLE = "Title";
	private static final String MESSAGE_ITEM_ERROR = "Unable to edit item %s";
	private static final String MESSAGE_ITEM_EDITED = "Item edited.";

	/** Strings to test with **/
	private static final String EMPTY_STRING = "";
	private static final String WHITESPACE_STRING = "                ";
	private static final String NUMBER_STRING = "1234567890";
	private static final String LONG_STRING = "This is a very long string made out of multiple words that can go on forever and ever and ever and ever";
	private static final String WEIRD_STRING = "T#is str/ng h@s we!rd $ymb^\\s. And punc!tuat!ion?";
	private static final String QUOTES_STRING = "\"This string has 'quotes' of both kinds\"";

	@BeforeClass
	public static void setUp() {
		ArrayList<Item> taskList = new ArrayList<Item>();
		Item task = new Item();
		task.setType("task");
		for (int i = 0; i < 10; i++) {
			taskList.add(task);
		}
		GUIModel.setTaskList(taskList);
		GUIModel.setTaskDoneList(taskList);
		ArrayList<Item> eventList = new ArrayList<Item>();
		Item event = new Item();
		event.setType("event");
		for (int i = 0; i < 10; i++) {
			eventList.add(event);
		}
		GUIModel.setEventList(eventList);
		GUIModel.setEventDoneList(eventList);
	}

	@Test
	public void testEditTitleNormalInputs() throws Exception {
		ArgsParserAbstract normalEdit = new EditParser("t1 title Title");
		ArgsParserAbstract normalEditLong = new EditParser("t1 title "
				+ LONG_STRING);
		ArgsParserAbstract normalEditWeird = new EditParser("t1 title "
				+ WEIRD_STRING);
		ArgsParserAbstract normalEditDiffTask = new EditParser("t2 title Title");
		ArgsParserAbstract normalEditLastTask = new EditParser(
				"t10 title Title");
		ArgsParserAbstract normalEditWithPunctuation = new EditParser(
				"t10 title Title");
		ArgsParserAbstract normalEditDoneTask = new EditParser("d1 title Title");
		ArgsParserAbstract normalEditEvent = new EditParser("e1 title Title");
		ArgsParserAbstract normalEditDoneEvent = new EditParser(
				"p1 title Title");
	}

	@Test
	public void testEditDateNormalInputs() throws Exception {
		ArgsParserAbstract normalEdit = new EditParser("t1 date 1 January 2015");
		ArgsParserAbstract normalEditDateFormat = new EditParser(
				"t1 date January 1 2015");
		ArgsParserAbstract normalEditShortDate = new EditParser("t1 date Jan 1");
		ArgsParserAbstract normalEditShortDateFormat = new EditParser(
				"t1 date 1 Jan");
		ArgsParserAbstract normalEditDateNoYear = new EditParser(
				"t1 date January 1");
		ArgsParserAbstract normalEditFlexiDate = new EditParser("t1 date today");
		ArgsParserAbstract normalEditEvent = new EditParser(
				"e1 date 1 January 2015");
		ArgsParserAbstract normalEditDoneTask = new EditParser(
				"d1 date 1 January 2015");
		ArgsParserAbstract normalEditDoneEvent = new EditParser(
				"p1 date 1 January 2015");
	}

	@Test
	public void testEditStartTimeNormalInputs() throws Exception {
		ArgsParserAbstract normalEdit = new EditParser("e1 start time 12pm");
		ArgsParserAbstract normalEditDiffFormat = new EditParser(
				"e1 start time 1200");
		ArgsParserAbstract normalEditDiffFormat2 = new EditParser(
				"e1 start time 12:00");
		ArgsParserAbstract normalEditDiffFormat3 = new EditParser(
				"e1 start time 12 p.m.");
		ArgsParserAbstract normalEditDiffFormat4 = new EditParser(
				"e1 start time 12 pm");
		ArgsParserAbstract normalEditDoneTask = new EditParser(
				"p1 start time 12pm");
	}

	@Test
	public void testEditEndTime() throws Exception {
		ArgsParserAbstract normalEdit = new EditParser("e1 end time 12pm");
		ArgsParserAbstract normalEditDiffFormat = new EditParser(
				"e1 end time 1200");
		ArgsParserAbstract normalEditDiffFormat2 = new EditParser(
				"e1 end time 12:00");
		ArgsParserAbstract normalEditDiffFormat3 = new EditParser(
				"e1 end time 12 p.m.");
		ArgsParserAbstract normalEditDiffFormat4 = new EditParser(
				"e1 end time 12 pm");
		ArgsParserAbstract normalEditDoneTask = new EditParser(
				"p1 end time 12pm");
	}

	@Test
	public void testEditTime() throws Exception {
		ArgsParserAbstract normalEdit = new EditParser("t1 time 12pm");
		ArgsParserAbstract normalEditDiffFormat = new EditParser("t1 time 1200");
		ArgsParserAbstract normalEditDiffFormat2 = new EditParser(
				"t1 time 12:00");
		ArgsParserAbstract normalEditDiffFormat3 = new EditParser(
				"t1 time 12 p.m.");
		ArgsParserAbstract normalEditDiffFormat4 = new EditParser(
				"t1 time 12 pm");
		ArgsParserAbstract normalEditDoneTask = new EditParser("d1 time 12pm");
	}

	@Test
	public void testWrongNumArgs() throws Exception {
		try {
			ArgsParserAbstract noInput = new EditParser(EMPTY_STRING);
		} catch (Exception e) {
			assertEquals(e.getMessage(), MESSAGE_INVALID_FORMAT);
		}
		try {
			ArgsParserAbstract singleArg = new EditParser("t1");
		} catch (Exception e) {
			assertEquals(e.getMessage(), MESSAGE_INVALID_FORMAT);
		}
		try {
			ArgsParserAbstract twoArgs = new EditParser("t1 title");
		} catch (Exception e) {
			assertEquals(e.getMessage(), MESSAGE_INVALID_FORMAT);
		}
	}

	@Test
	public void testInvalidField() throws Exception {
		String[] invalidMsg = new String[1];
		invalidMsg[0] = MESSAGE_INVALID_FIELD;
		String result = String.format(MESSAGE_HEADER_INVALID,
				Arrays.toString(invalidMsg));
		try {
			ArgsParserAbstract noSuchField = new EditParser(
					"t1 invalidField invalid nonsense");
		} catch (Exception e) {
			assertEquals(e.getMessage(), result);
		}
	}

	@Test
	public void testEditTaskStartTime() throws Exception {
		String[] invalidMsg = new String[1];
		invalidMsg[0] = MESSAGE_INVALID_TASK_START;
		String result = String.format(MESSAGE_HEADER_INVALID,
				Arrays.toString(invalidMsg));
		try {
			ArgsParserAbstract taskStartTime = new EditParser(
					"t1 start time 12pm");
		} catch (Exception e) {
			assertEquals(e.getMessage(), result);
		}
	}

	@Test
	public void testInvalidID() throws Exception {
		String[] invalidMsg = new String[1];
		invalidMsg[0] = MESSAGE_INVALID_ITEM_ID;
		String result = String.format(MESSAGE_HEADER_INVALID,
				Arrays.toString(invalidMsg));
		try {
			ArgsParserAbstract itemOutOfBounds = new EditParser(
					"t100 title test");
		} catch (Exception e) {
			assertEquals(e.getMessage(), result);
		}
		try {
			ArgsParserAbstract itemZero = new EditParser("t0 title test");
		} catch (Exception e) {
			assertEquals(e.getMessage(), result);
		}
	}

	@Test
	public void testInvalidDate() throws Exception {
		String[] invalidMsg = new String[1];
		invalidMsg[0] = MESSAGE_INVALID_DATE;
		String result = String.format(MESSAGE_HEADER_INVALID,
				Arrays.toString(invalidMsg));
		try {
			ArgsParserAbstract taskInvalidDate = new EditParser(
					"t1 date Jan 32");
		} catch (Exception e) {
			assertEquals(e.getMessage(), result);
		}
		try {
			ArgsParserAbstract eventInvalidDate = new EditParser(
					"e1 date Jan 32");
		} catch (Exception e) {
			assertEquals(e.getMessage(), result);
		}
	}

	@Test
	public void testInvalidTimeStart() throws Exception {
		String[] invalidMsg = new String[1];
		invalidMsg[0] = MESSAGE_INVALID_TIME_START;
		String result = String.format(MESSAGE_HEADER_INVALID,
				Arrays.toString(invalidMsg));
		try {
			ArgsParserAbstract eventStartTime = new EditParser(
					"e1 start time 25pm");
		} catch (Exception e) {
			assertEquals(e.getMessage(), result);
		}
	}

	@Test
	public void testInvalidTimeEnd() throws Exception {
		String[] invalidMsg = new String[1];
		invalidMsg[0] = MESSAGE_INVALID_TIME_END;
		String result = String.format(MESSAGE_HEADER_INVALID,
				Arrays.toString(invalidMsg));
		try {
			ArgsParserAbstract taskEndTime = new EditParser("t1 end time 25pm");
		} catch (Exception e) {
			assertEquals(e.getMessage(), result);
		}
		try {
			ArgsParserAbstract eventEndTime = new EditParser("e1 end time 25pm");
		} catch (Exception e) {
			assertEquals(e.getMessage(), result);
		}
	}

	@Test
	public void testInvalidTitle() throws Exception {
		String[] invalidMsg = new String[1];
		invalidMsg[0] = MESSAGE_INVALID_TITLE;
		String result = String.format(MESSAGE_HEADER_INVALID,
				Arrays.toString(invalidMsg));
		try {
			EditParser taskEndTime = new EditParser("t1 title " + EMPTY_STRING);
		} catch (Exception e) {
			assertEquals(e.getMessage(), result);
		}
	}

	@AfterClass
	public static void tearDown() {
		GUIModel.taskList = null;
		GUIModel.taskDoneList = null;
		GUIModel.eventDoneList = null;
		GUIModel.eventDoneList = null;
	}

}
```
###### parser\EventParserTest.java
``` java
 */

import java.util.ArrayList;

import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;

import gui.GUIModel;
import main.Item;

public class EventParserTest {

	protected static final String MESSAGE_HEADER_INVALID = "Invalid arguments: ";
	private static final String MESSAGE_INVALID_FORMAT = "Use format: event <title> "
			+ "from <start date> <start time> " + "to <end date> <end time>";
	private static final String MESSAGE_INVALID_DATETIME_END = "[End date/time]";
	private static final String MESSAGE_INVALID_DATETIME_START = "[Start date/time]";
	private static final String MESSAGE_INVALID_DATETIME_START_END = "[End date/time, Start date/time]";
	private static final String MESSAGE_INVALID_DATETIME_RANGE = "[End date/time is earlier than Start date/time]";
	private static final String MESSAGE_INVALID_TITLE = "[Title]";
	private static final String MESSAGE_EVENT_ADDED = "event added";
	private static final String MESSAGE_EVENT_CLASH = ". Another event exists on the same date.";
	private static final String MESSAGE_EVENT_ERROR = "unable to add event";

	/** Strings to test with **/
	private static final String EMPTY_STRING = "";
	private static final String WHITESPACE_STRING = "                ";
	private static final String NUMBER_STRING = "1234567890";
	private static final String LONG_STRING = "This is a very long string made out of multiple words that can go on forever and ever and ever and ever";
	private static final String WEIRD_STRING = "T#is str/ng h@s we!rd $ymb^\\s. And punc!tuat!ion?";
	private static final String QUOTES_STRING = "\"This string has 'quotes' of both kinds\"";
	private static final String DATE_STRING = " from January 1 12pm to January 1 1pm";

	@BeforeClass
	public static void setUp() {
		ArrayList<Item> taskList = new ArrayList<Item>();
		Item task = new Item();
		task.setType("task");
		for (int i = 0; i < 10; i++) {
			taskList.add(task);
		}
		GUIModel.setTaskList(taskList);
		GUIModel.setTaskDoneList(taskList);
		ArrayList<Item> eventList = new ArrayList<Item>();
		Item event = new Item();
		event.setType("event");
		for (int i = 0; i < 10; i++) {
			eventList.add(event);
		}
		GUIModel.setEventList(eventList);
		GUIModel.setEventDoneList(eventList);
	}

	@Test
	public void testNormalInputs() throws Exception {
		EventParser normalEvent = new EventParser("Event" + DATE_STRING);
		EventParser normalEvent2 = new EventParser(
				"Event from today to tomorrow");
		EventParser normalEventDateFlipped = new EventParser(
				"Event from 1 Jan 12pm to 1 Jan 1pm");
		EventParser normalEventWithYear = new EventParser(
				"Event from January 1 2016 12pm to January 1 2016 1pm");
		EventParser normalEventToday = new EventParser(
				"Event from today 12pm to today 1pm");
		EventParser normalEventLongPeriod = new EventParser(
				"Event from today 12pm to Jan 1 2115 1pm");
		EventParser normalEventLongTitle = new EventParser(LONG_STRING
				+ DATE_STRING);
		EventParser normalEventWeirdTitle = new EventParser(WEIRD_STRING
				+ DATE_STRING);
		EventParser normalEventPastYear = new EventParser(
				"Grad trip with Harry Potter from 17 Dec 11pm to 10 January 12am");
	}

	@Test
	public void testWrongNumInputs() throws Exception {
		try {
			EventParser noInput = new EventParser("");
		} catch (Exception e) {
			assertEquals(e.getMessage(), MESSAGE_INVALID_FORMAT);
		}
		try {
			EventParser justID = new EventParser("t1");
		} catch (Exception e) {
			assertEquals(e.getMessage(), MESSAGE_INVALID_FORMAT);
		}
		try {
			EventParser noFrom = new EventParser(
					"t1 January 1 12pm to January 1 1pm");
		} catch (Exception e) {
			assertEquals(e.getMessage(), MESSAGE_INVALID_FORMAT);
		}
		try {
			EventParser noTo = new EventParser(
					"t1 from January 1 12pm January 1 1pm");
		} catch (Exception e) {
			assertEquals(e.getMessage(), MESSAGE_INVALID_FORMAT);
		}
	}

	@Test
	public void testInvalidInputs() throws Exception {
		try {
			EventParser noTitle = new EventParser(EMPTY_STRING + DATE_STRING);
		} catch (Exception e) {
			assertEquals(e.getMessage(), MESSAGE_HEADER_INVALID
					+ MESSAGE_INVALID_TITLE);
		}
		try {
			EventParser nonExistentDate = new EventParser(
					"Event from January 32 12pm to January 32 1pm");
		} catch (Exception e) {
			assertEquals(e.getMessage(), MESSAGE_HEADER_INVALID
					+ MESSAGE_INVALID_DATETIME_START_END);
		}
		try {
			EventParser nonExistentTime = new EventParser(
					"Event from January 1 25pm to January 1 26pm");
		} catch (Exception e) {
			assertEquals(e.getMessage(), MESSAGE_HEADER_INVALID
					+ MESSAGE_INVALID_DATETIME_START_END);
		}
	}

	@AfterClass
	public static void tearDown() {
		GUIModel.taskList = null;
		GUIModel.taskDoneList = null;
		GUIModel.eventDoneList = null;
		GUIModel.eventDoneList = null;
	}

}
```
